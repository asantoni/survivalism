/*
SERVER FLAGS TO USE:
	alwaysapplydmflags true
	sv_defaultdmflags false
	sv_weaponstay false

r16:
- Auto load/save system
- Backpack drops
- TODO: Perma powerups and artifacts?
- TODO: Connected Maps
- TODO: Radiation Zone
    
r14test15:
- Berry system
- Fixed a bunch of hunger related bugs.

TODO r14:
- Actually make some good quests

r14 test13:
- Fixed monster spawner being blocked when you stood beside a torch.
- Hunger system! Starts at level 14.
- Chainsaw respawn fix for DoomZ2

DONE r14 bugs:
- receiving XP during leveling up gives you an extra level
- Sentries don't damage constructed buildings now
- turret kills give XP -> solved with damagetype
- daylight kills might still give XP? -> solved with damagetype
- something is randomly calling the cancel quest script... ? Or fail quest script? - it's when a quest expires?
- Sentries are quieter now
- Can't shoot arrows through boxes anymore
- Cleanup of the Dragon Quest works correctly if you finish it, but cancelling it does not work at all.
***Should we make it uncancellable? And make everything disappear after 25 minutes?
  (How do we remove the dragon in a way that removes the mapspots too but doesn't drop loot?)
   - the map spots disappear after 25 minutes, but how can we remove the dragon??
- Nixed the Imp Warlord familiars so they don't ravage the spawn on doomz2
- Eliminated the pseudo-spectator mode and 15 second respawn timer because it was too buggy


DONE r14 tasks:
- TEST! Especially in multiplayer
- Revisit easy/medium/hard quest spots in DoomZ1
Sounds/Music:
	- Level up
	- Picked up item
	- XP received
	- Quest started
	- Quest objective completed
	- Quest completed
- Disable baddies.acs 505 script NET
- Place easy/medium/hard quest spots in DoomZ3
- Place easy/medium/hard quest spots in DoomZ2
- Make levelling up bling
- Procedural vegetation system
- Hunting Rifle uses 4 bullet ammo per shot now, but also does 25% more damage.

DONE r14:
- Quests!
- XP and level system
- Crafting unlocks for leveling up
- Scrolls that show what you unlocked at each level.
- XP meter showing progress
- Revamped the chaingun, shotgun, hunting rifle, axe, knife and tweaked the other weapons
- Ammo can be stockpiled (ClipBox and ShellBox can be inventory)
- No ammo drops at night. You must scavenge for it during the day now.
- Axe alt-fire unlockable (heavy swing) at level 13
- Advanced Chicken AI - Chickens now get hungry and sleep!
- New Craftable: Spikes for base defense
- Fixed DoomZFlamePawn actor leaks in trees and logs (should reduce CPU usage in long-running games)
- Hemp seeds
- Small improvements to monster spawning - Enemies don't spawn in trees anymore, and optimized the see/hear distances
- Fixed not being able to activate crafting boxes sometimes
- Zombies can now attack logs, so you can't build a wall out of them.
- Decrease number of eggs chickens lay until there's 40 chickens
- The fire spell no longer floats away (though many good adventures were had trying to get it down).
- Maps: DoomZ1 and DoomZ3 updated! 
- ZombieIncarnates have more health
- Slightly overhauled menu screens
r14 beta:
- Enemies can attack your crops. Protect them!
- Ghouls buffed and more fun again.
- Chicken hunger graphics fixed
- Azazel mission no longer results in net traffic spam / disconnection
- Shotgun has vertical spread now
- Torches fixed - preventing zombies from spawning was borked
- Threw in the occasional Mancubus... !
- Every 4 nights there will be a more difficult night. Be prepared.
r14 beta2:
- Fixed rocks not respawning (Zandronum 2.0 compatibility issue)
- Wood doesn't pass through solid actors (like your base) anymore.
- Nerfed the Mancubus night
- Added tags for all items (human-readable names)

r14 test 11:
- Splashes - Thanks Enjay!
- Water bucket! Water your plants to have them grow faster
- Fixed monster spawner being slightly broken in Zandronum 2.0 - Now more action packed.
- Reimplemented torches stopping monsters from spawning, twice. Uses even less CPU now and works better than ever.
- Better water sounds


DONE r13fix3:
- Deep water in DoomZ3
- Turrets don't shoot planted trees anymore
- Doors are little bit stronger now
- To prevent inventory exploit, you can only load your inventory once per game!
- r13fix2: Fixed doors, crafting boxes, and furnaces from breaking (for real this time)

DONE r13:
- Chop logs to get wood now! 
- Chickens can be picked up!
- Box placer gun can place pillars, floors, and doors now
- Torches light a bigger area
- Torches work better at preventing monsters from spawning
- Light logs on fire for campfires!
- Fire can spread now. (logs and trees can catch on fire)
- Doors work way better now.
- Dogs spawn in packs now
- Zandronum 2.0 compatibility
- New, rare vanity items
- Two new guns
- New boss! And a special weapon as a reward.
- Some crazy ACS / DECORATE to make a simple raft. :)
- Loot boxes spawn 
- Ghouls are not ridiculously hard now
- Monster spawner charge
- Furnace
- Box placer gun improved - Less glitchy collsion detection. It's much harder to place boxes inside boxes now.
- Tree growth is slower
- Doors spawn a bit lower
- Title screen map and logo!
- Respawning turnips in a few spots on DoomZ2
- Chainsaw gas

Deferred to r14:
- Steel

DONE r12:
- Torches stop monsters from spawning

DONE r11:
- Persistent inventory!!!!!!!! (Save it from the basic crafting menu!)
- Crafting - Basic crafting menu and crafting boxes.
- Ninja rope by AEnima! Find hemp and use the alt-fire on your bow.
- Major revamp to DoomZ2!
- Added Glock18.
- Polished the weapons more. Timings tweaked, shell casings, and pistols are semi-auto now. 
- The knife slashes faster, so it's actually useful now.
- Revamped DECORATE for most monsters. Less buggy!
- Loot dropping mechanic changed: Monsters drop loot now, and harder monsters
  drop better loot. Random loot still drops, but is now much more rare.
- Completely rewritten monster spawner, no more monsters outside the map!
- Fixed a bunch of tree growing bugs 
- Scientist unblocking bug - Map too big! Must be within 9400 x 9400 map units.
- Chickens don't lay eggs so fast >:
- Box placer gun moved to slot 0
- The DoomZ2 revamp fixed monsters being unshootable sometimes.
- Creepers fixed, now more 'splodey. And green!
- Fixed broken door in secret.
- Fixed mountain music not playing locally (hopefully)
- Fixed monsters not spawning enough in the west.
- Fixed suicide/XDeath not dropping your stuff.
- Fixed crappy DECORATE coding. New AI for all monsters.
- Baron of Hell is now harder.
- Added demon dogs to forest
- More spawns!!!
- Added DoomZShadow and DoomZDemonDog

TODO NEXT:
- Chicken cooking
- More events
- Spikes crafting
- Heracross says one of the old Doom alphas on idgames has a pinky death animation
  where it explodes...
- Fix pinky death message. 
- Grab lighter from Ao Oni?
- TODO NEXT r11:
   - Monster Spawner 3.0 DONE
   - Loot Spawner 3.0 DONE
	- Fix burning trees
	- Beds?
	- Fireplace / Furnace?

	

DONE r10:
- Chickens (and one pig). Chickens lay eggs!
- Chickens can be cooked with fire
- Monsters spawn at better heights now
- Arrows shot with the bow now arc
- Death wyvern on big mountain
- Less pinkies
- Swamp area improved
- Turnip Farming
- Bigger DoomZ2
- Fixed spectator respawn death

FIXED r9:
- You can screw up the monster spawner mode if you spectate in an area then join again?
   - or if you die in the swamp?
- You can still sometimes never respawn -> Delay(1) between Clear and Give inventory!
- Turrets were bugged - Ethril says have them clear their targets every once and a while --> That worked!
- Items don't fall through floors now!
- Events are more reliable, but don't happen as often (~ 9 minutes)


MAYBE FIX:
- ^^^ I think I should not use inventory for server-side state! --> Delay() seems to make it work 
    - I'm guessing all actions are timestamped by tic in the netcode, and order is only guaranteed if 
	  actions/function calls occur at different tics.
- All items should destroy themselves after a long time (10 mins?)
- Spread out the boxes more (Dr. Corrupt)

FIXED r8:
- Tweak the amount of stuff in the construction kit
- Add a "Hit F1 for instructions!" blurb when you join
   - Say required OpenGL and gl_use_models 1
- Make bow and arrow ammo destructible
- Add skin for door blocks
- Trees disappearing after you hit them once in multiplayer
- Don't drop axe or box placer gun
- Turrets shoot rocks
- Some rock hitboxes too big
- Some trees (near big cave entrance, jungle trees) are not solid
- Fix stuff getting stuck in the sky (get the Z spawn height from an ACS function that goes higher each time?)
		-> Use DECORATE "fail" flow control statement if Used too fast


TODO:
- Make difficulty become less with more people. Too difficult now
     (at least during day...)
- Disasters: Wind, meteor
- Melee key (SpawnProjectile a punch projectile?)
- Make the arrows go a bit faster for Dr. Badass
- Lava outside map to kill monsters?
- 2D placeholder for 3D box so non-openGL ppl see something
- Meteor shower - replace rocket sprite with meteor
- Anti-camping?
- Jumping zombies / more monster types to make camping
  harder
- explosive zombies, faster zombies?>
- Fireplace?
- Backpack loot drop
- Item storage?
- Custom survial gamemode with slow respawns
- Fix creepers being able to kill you through walls
   - also +THRUMONSTERS for creepers (check?)
- Random resource cluster spawner
   - Make a monster that moves super fast with A_Wander right
     at the start of the map and spawns resource clusters
- Coop with team damage
- Sprint/stamina mechanic - put away guns to sprint? 
     And tap in rhythm to sprint?
- Crafting
- More missions
- Loot storage
- NPCs in town to buy stuff off of
- Stop dropping loot if players are camping!
DONE:
-r7 DONE:
- Torches!
- New tree harvesting system
- MINING! Mine rocks to make stone blocks! 
- Added a cave with respawning rocks to doomz2
- Better foliage, way more foliage
- Monster spawner still spawning for pseudospeced people
- Make day zombies not attack bases as much
- Axe by default, construction gun by default
- Fixed redhead and brown head scientists not disappearing!
- Crash when dying (SyKoTiC) - Fixed - it was the Axe!
- Fixed the loot probabilities?
- The BE server is now coop (so item drops work), no team damage 
  
- 30 second player respawn time if numplayers > 1
- fix spawn animations for all zombie scientists
- Non-linear day/night cycle
- add mudmen to swamp
- Make fog colour change with day/night cycle
- Turnip farming
- Zombies attack bases more, change modes on the fly
- Imp storm
- Dead trees choppable but regrow super slow
- Fixed pinky sound bug
- Turn off "give all keys" in the server config
- Enable dropping stuff in multiplayer
- Add Death Incarnates that spawn during the night, are harder
  but die during the day
- Set TID on baddie death, then sweep the bodies after a while
- Armour
- Bow
- PROBABILITIES.acs
- Add SSG drop for Hell Knight
- "it needs more challenge and a less laggy random spawner" -
- roofs on bases and doors
- missions?
- make punches weaker
*/

#library "doomzgame"
#include "zcommon.acs"
#import "missions.acs"
#import "player.acs"
#import "math.acs"
#import "music.acs"
#import "probabilities.acs"
#import "quests.acs"
#import "ACSNET.acs"

#libdefine MISSION_MONSTER_TID 5000
#define RANDOM_LOOT_TID_MIN 8000
#define RANDOM_LOOT_TID_MAX 8099
#libdefine BADDIES_TID_MIN 8200
#libdefine BADDIES_TID_MAX 8399
#libdefine DEATH_TID_MIN 8450
#libdefine DEATH_TID_MAX 8499
#libdefine ANKH_TID_MIN 8500
#libdefine ANKH_TID_MAX 8549
#define PARACHUTE_TID_MIN 8550
#define PARACHUTE_TID_MAX 8604
#libdefine CONSTRUCTION_TID 99
#libdefine MINE_ROCK_TID 554
#define MONSTERSPAWNERPROJ_TID 8400
#libdefine MONSTER_REPELLER_TID 8401
//555 is used by respawn points
#libdefine SEED_TID 		8402
#libdefine FOOD_TID 		8403
#libdefine BERRY_PLANT_TID 	8404
#libdefine WILD_BIRD_TID    8405
#libdefine VEGETATION_TID   8888
//Reserve a thousand TIDs for UniqueTID calls. You must use these with that so it doesn't take one of our other reserved TIDs!
#libdefine SAFE_UNIQUE_TID_MIN  19000
#libdefine SAFE_UNIQUE_TID_MAX  22999


#libdefine DAYSTATE_DAY 	0
#libdefine DAYSTATE_NIGHT 	1

#define NUM_SKY_TEXTURES 32 // 0-31

#DEFINE MONSTER_SPAWNER_MODE_OFF 3

#define LOOT_SPAWNER_INTERVAL_SECONDS 20*60 //20 minutes
#define BERRY_SPAWNER_INTERVAL_SECONDS 6*60 //12 minutes (1 day) in r15 originally
#define BASE_BERRY_PLANTS 12

#libdefine HUNGER_PERIOD_SECONDS 5040 //Time it takes to starve - 1.5 days originally (1080 s), changed to 7 days to nerf the hunger system

#define BASE_CROW_COUNT 25
#define BIRD_SPAWNER_INTERVAL_SECONDS 5*60

#libdefine DEBUG_MODE 1

//#libdefine kMainLoopPeriodSeconds 20
int kMainLoopPeriodSeconds = 20;
int kDayLengthSeconds = 12*60;
int g_timeOfDaySeconds = 0;
int g_dayNumber = 1;
int g_dayState = DAYSTATE_DAY;
int g_blockXP = false; //global lock for XP, to prevent players from getting free XP from monsters dying at daybreak

//Clientside preferences:
int g_vegetationEnabled = true;


#libdefine NUM_MONSTER_SPAWNER_MODES 8
int g_maxBaddiesForSpawnerMode[NUM_MONSTER_SPAWNER_MODES] =
	{ 16, //Default monsters (zombie mix)
	  8, //Imps
	  8,  //Swamp mudmen (ghouls)
	  0,  //Safe zone (no monsters)
	  8,  //Shadows
	  10, //Forest zone
      8,  //Hell Knight zone (Iron Mine)
      5,  //Radiation Zone
	};

//Called when the level loads
script 200 OPEN
{	
	//Random loot every 10 minutes
	ACS_ExecuteAlways(201, 0, 0, 0, 0);
	
	if (GameType() == GAME_TITLE_MAP)
	{
		kMainLoopPeriodSeconds = 2;
		kDayLengthSeconds = 48;
	}
	
	//Main game loop
	while (true)
	{
		g_timeOfDaySeconds += kMainLoopPeriodSeconds;
		if (g_timeOfDaySeconds > kDayLengthSeconds) {
			g_dayNumber++;
			g_timeOfDaySeconds = g_timeOfDaySeconds % kDayLengthSeconds;
		}
		
		//Day/night cycle
		ACS_ExecuteAlways(210, 0, 0, 0, 0);

		//Spawn random loot around each player
		//ACS_ExecuteAlways(201, 0, 0, 0, 0);
		
		//Spawn random badguys around each player
		//ACS_ExecuteAlways(202, 0, 0, 0, 0);

		//Mission spawner - see MISSIONS.acs
		ACS_ExecuteAlways(820, 0, 0, 0, 0);
		
        //Track how long each player has been playing for.
        for (int playerIdx = 0; playerIdx < MAX_PLAYERS; playerIdx++) {
            g_secondsSincePlayerJoined[playerIdx] += kMainLoopPeriodSeconds;
        }
        
		//Sleep
		Delay(35*kMainLoopPeriodSeconds);
	}
}

script 221 OPEN
{
	while (true)	
	{
		//Spawn random badguys around each player
		ACS_ExecuteAlways(202, 0, 0, 0, 0);

		//Sleep
		Delay(8*35);
	}
}

//Spawn random loot in a frustrum around each player.
//TODO: Stop dropping loot if players are camping!
/* Old loot dropping code... 
script 201 (void)
{
	int kNumLootBoxesPerPlayer = 3;
	int kMinLootRadius = 1024; //Min distance to player for loot spawning
	int kMaxLootRadius = 2048; //Max distance from player for loot spawning

	for (int playerTid = PLAYER_MIN_TID;
		 playerTid < PLAYER_MIN_TID+PlayerCount();
		 playerTid++)
	{
		int playerOffset = playerTid - PLAYER_MIN_TID;
		int tid = RANDOM_LOOT_TID_MIN + playerOffset;

		//Ignore spectators and pseudospectators (players who haven't respawned yet)
		if (PlayerIsSpectator(playerOffset) > 0 || PlayerIsPseudoSpec(playerOffset)) 
		{
			continue;
		}
		
		int playerX = GetActorX(playerTid);
		int playerY = GetActorY(playerTid);
		int playerZ = GetActorZ(playerTid);
		int numLootAliveForPlayer = ThingCount(T_NONE, tid);
		
		//Spawn up to N loot boxes within a certain radius
		//of the player.
		if (numLootAliveForPlayer < kNumLootBoxesPerPlayer)
		{
			int numLootToSpawn = kNumLootBoxesPerPlayer - numLootAliveForPlayer;

			//Spawn loot in polar coords, within some radius
			//of the player.
			for (int i = 0; i < numLootToSpawn; i++)
			{
				int herpderpangle = random(0, 65536);
				int x = random(kMinLootRadius, kMaxLootRadius)*sin(herpderpangle);
				int y = random(kMinLootRadius, kMaxLootRadius)*cos(herpderpangle);
				int z = 32;
				//Center the loot around the player
				x += playerX;
				y += playerY;
				z += playerZ;
				
				Spawn("LootBox", x, y, z, tid);
			}
		}
	}
}*/

/* Spawn random loot around each player every once and a while */
script 201 (void)
{
	int kNumLootPerPlayer = 2;

	while (true)
	{
		Delay(35*LOOT_SPAWNER_INTERVAL_SECONDS);

		for (int playerTid = PLAYER_MIN_TID;
			 playerTid < PLAYER_MIN_TID+PlayerCount();
			 playerTid++)
		{
			int playerOffset = playerTid - PLAYER_MIN_TID;
			
			//Ignore spectators, pseudospectators (players who haven't respawned yet),
			//and dead players!
			if ((PlayerIsSpectator(playerOffset) > 0) || (PlayerIsPseudoSpec(playerOffset))
				|| (ClassifyActor(playerTid) & ACTOR_DEAD)) 
			{
				continue;
			}

			int playerX = GetActorX(playerTid);
			int playerY = GetActorY(playerTid);
			int playerZ = GetActorZ(playerTid);
			//int monsterSpawnerModeForPlayer = CheckActorInventory(playerTid, "MonsterSpawnerMode");
			//int numBadGuysAliveForPlayer = ThingCount(T_NONE, tid);
			
			for (int i = 0; i < kNumLootPerPlayer; i++)
			{
				int distance = 80;
				int speed = distance;
				SpawnProjectile(playerTid, "DoomZLootSpawnerProjectile",  random(0, 65536),  speed, 0, 0, 0);	
			}
		}
	}
}

//Monster Spawner V3:
script 202 (void)
{
	for (int playerTid = PLAYER_MIN_TID;
		 playerTid < PLAYER_MIN_TID+PlayerCount();
		 playerTid++)
	{
    
    	int playerOffset = playerTid - PLAYER_MIN_TID;
		int tid = BADDIES_TID_MIN + playerOffset;

    	int kNumBaseBadGuysPerPlayer = 5; //rsomething-r12: 10 //First versions: 3
      
        if (g_dayState == DAYSTATE_NIGHT)
        {
            //Ramp up difficulty at night but only after your first day
            if ((g_secondsSincePlayerJoined[playerOffset] < kDayLengthSeconds) && (DEBUG_MODE==0)) { 
                kNumBaseBadGuysPerPlayer = 6;
            } else {
                kNumBaseBadGuysPerPlayer = 16; //12
            }
        }
        //Ramp it up linearly over the first day...
        int kNumBadGuysPerPlayer = math_min(kNumBaseBadGuysPerPlayer, FixedMul(kNumBaseBadGuysPerPlayer<<16, FixedDiv(g_secondsSincePlayerJoined[playerOffset] << 16, kDayLengthSeconds << 16))>>16);
        if (DEBUG_MODE==1) {
            kNumBadGuysPerPlayer = kNumBaseBadGuysPerPlayer;
        }

		//Ignore spectators, pseudospectators (players who haven't respawned yet),
		//and dead players!
		if ((PlayerIsSpectator(playerOffset) > 0) || (PlayerIsPseudoSpec(playerOffset))
		    || (ClassifyActor(playerTid) & ACTOR_DEAD)) 
		{
			continue;
		}

		int playerX = GetActorX(playerTid);
		int playerY = GetActorY(playerTid);
		int playerZ = GetActorZ(playerTid);
		int monsterSpawnerModeForPlayer = CheckActorInventory(playerTid, "MonsterSpawnerMode");
		int numBadGuysAliveForPlayer = ThingCount(T_NONE, tid);
		
		//Clamp based on the monster spawner mode. Eg. We want less ghouls because they're so hard.
		//maxBadGuysForThisPlayer = math_min(kNumBadGuysPerPlayer, g_maxBaddiesForSpawnerMode[monsterSpawnerModeForPlayer]);
		
		//Spawn up to N bad guys within a certain radius
		//of the player.
		//if ((numBadGuysAliveForPlayer < kNumBadGuysPerPlayer) &&
		if (monsterSpawnerModeForPlayer != MONSTER_SPAWNER_MODE_OFF)
		{
			int monsterSpawnerChargeForPlayer = CheckActorInventory(playerTid, "MonsterSpawnerCharge");
			//Log(d:monsterSpawnerChargeForPlayer);

			int numBaddiesToSpawn;
			if (g_dayState == DAYSTATE_NIGHT) {
				numBaddiesToSpawn = kNumBadGuysPerPlayer - numBadGuysAliveForPlayer;
			} else { //Day
				numBaddiesToSpawn = math_min(g_maxBaddiesForSpawnerMode[monsterSpawnerModeForPlayer], kNumBadGuysPerPlayer*math_max(0.7*monsterSpawnerChargeForPlayer*monsterSpawnerChargeForPlayer, 1)) - numBadGuysAliveForPlayer;
				//Clamp based on the monster spawner mode. Eg. We want less ghouls because they're so hard.
				//Log(d:numBaddiesToSpawn);

				//numBaddiesToSpawn = math_max(numBaddiesToSpawn, g_maxBaddiesForSpawnerMode[monsterSpawnerModeForPlayer]);
				//Log(d:numBaddiesToSpawn);
			}
			
			//Spawn baddies in polar coords, within some radius
			//of the player.
			for (int i = 0; i < numBaddiesToSpawn; i++)
			{
				int distance = 80;
				int speed = distance;
			  // playerX, playerY, playerZ, 
				SpawnProjectile(playerTid, "DoomZMonsterSpawnerProjectile",  random(0, 65536),  speed, 0, 0, tid);	
				//SpawnForced("DoomZMonsterSpawnerProjectile", playerX, playerY, playerZ, tid, random(0, 255));
			}
		}
	}
}

//Spawn a random monster.
//Get this gets called by the DoomZMonsterSpawnerProjectile when it dies.
script 203 (void)
{
	int tid = ActivatorTID(); //Using getActorX/Y/Z with this doesn't work for some reason,
						      // we have to use getActorX/Y/Z(0) instead.
	int x = getActorX(0);  //Don't use tid here!
	int y = getActorY(0);
	//int z = getActorZ(0);
	int z = getActorFloorZ(0); //Spawn on the floor beneath the projectile
	
	int randomFacingAngle = random(0, 65536);
	//Thing_ChangeTID(0, 0); //Removes the TID of the activator only
	//Spawn("DoomZFemaleScientist", x, y, z, tid, randomFacingAngle); --> not working
	//I don't know why we have to use SpawnProjectile but we do here:
	
	//IMPORTANT: The max delay length here must be less than the duration of the Death
	//			 state in DoomZMonsterSpawnerProjectile, because the TID of the 
	//			 projectile could otherwise go away before this code reassigns it.
	//Thing_ChangeTID(tid, 0);
	//Delay(random(0, 150)); //READ ABOVE BEFORE TOUCHING

	//Convert the baddie TID back into the player TID
	int playerOffset = tid - BADDIES_TID_MIN;
	int playerTid = PLAYER_MIN_TID + playerOffset;
	//int tid = BADDIES_TID_MIN + playerOffset;
	//print(s:"activator TID is: ", d:tid);
	int monsterSpawnerModeForPlayer = CheckActorInventory(playerTid, "MonsterSpawnerMode");
	//Not using the charge here (yet?):
	//int monsterSpawnerChargeForPlayer = CheckActorInventory(playerTid, "MonsterSpawnerCharge");

	//Thing_ChangeTID(0, 0); //Removes the TID of the activator only
	//SpawnProjectile(0, "DoomZFemaleScientist",  randomFacingAngle,  0, 0, 1.0, tid); //Works!
	//Spawn("DoomZFemaleScientist", x, y, z, tid, randomFacingAngle); //--> not working

	//pawn("DoomZFemaleScientist", x, y, z, tid, randomFacingAngle);
	//SpawnForced("DoomZFemaleScientist", x, y, z, tid, randomFacingAngle);
	
	//Spawn("DoomZFemaleScientist", x, y, z-128.0, tid, randomFacingAngle);//, tid, randomFacingAngle); //--> not working

	int zOffset = 0.0; //-128.0;
    
    int tempTID = UniqueTID(SAFE_UNIQUE_TID_MIN);
	int randomSpawnType = 0;
    
	switch (monsterSpawnerModeForPlayer)
	{
		case 1: //Imp zone
			if (g_dayState == DAYSTATE_NIGHT) {
				//SpawnProjectile(0, "DoomZNightImp", randomFacingAngle, 0, 0, 1.0, tid);
				Spawn("DoomZNightImp", x, y, z+zOffset, tempTID, randomFacingAngle);
			} else {
				//SpawnProjectile(0, "DoomZImp", randomFacingAngle, 0, 0, 1.0, tid);
				Spawn("DoomZMeleeImp", x, y, z+zOffset, tempTID, randomFacingAngle);
			}
			break;

		case 2: //Ghoul zone
			if (g_dayState == DAYSTATE_NIGHT) {
				//SpawnProjectile(0, "DoomZGhoul", randomFacingAngle, 0, 0, 1.0, tid);
				Spawn("DoomZGhoul", x, y, z+zOffset, tempTID, randomFacingAngle);
			} else {
				//SpawnProjectile(0, "DoomZGhoul", randomFacingAngle, 0, 0, 1.0, tid);
				Spawn("DoomZGhoul", x, y, z+zOffset, tempTID, randomFacingAngle);
			}
			break;
			
		case 3: //No monsters
			break;
		case 4: //Shadow zone
			if (g_dayState == DAYSTATE_NIGHT) {
				//SpawnProjectile(0, "DoomZGhoul", randomFacingAngle, 0, 0, 1.0, tid);
				Spawn("DoomZGhoul", x, y, z+zOffset, tempTID, randomFacingAngle);
			} else {
				//SpawnProjectile(0, "DoomZShadow", randomFacingAngle, 0, 0, 1.0, tid);
				Spawn("DoomZShadow", x, y, z+zOffset, tempTID, randomFacingAngle);
			}
			break;
		case 5: //Forest zone
			if (g_dayState == DAYSTATE_NIGHT) {
				Spawn("DoomZIncarnate", x, y, z+zOffset, tempTID, randomFacingAngle);
			} else {
				Spawn("DoomZDemonDog", x, y, z+zOffset, tempTID, randomFacingAngle);
			}
			break;
		case 6: //Hell knight zone (Iron Mine)
			if (g_dayState == DAYSTATE_NIGHT) {
				Spawn("DoomZBaronOfHellCommon", x, y, z+zOffset, tempTID, randomFacingAngle);
			} else {
            	randomSpawnType = random(1, 100);
                if (randomSpawnType % 3 == 0) {
                    Spawn("ImpWarlord", x, y, z+zOffset, tempTID, randomFacingAngle);
                } else {
                    Spawn("DoomZHellKnightCommon", x, y, z+zOffset, tempTID, randomFacingAngle);
                }
			}
			break;
		case 7: //Radiation Zone
			if (g_dayState == DAYSTATE_NIGHT) {
                Spawn("ApprenticeOfDsparil", x, y, z+zOffset, tempTID, randomFacingAngle);
			} else {
            	randomSpawnType = random(1, 100);
                if (randomSpawnType % 8 == 0) {
                    Spawn("ApprenticeOfDsparil", x, y, z+zOffset, tempTID, randomFacingAngle);
                } else {
                    Spawn("CrimsonDisciple", x, y, z+zOffset, tempTID, randomFacingAngle);
                }
			}
			break;

		default: //0 too
			randomSpawnType = random(1, 100);
			if (randomSpawnType % 30 == 0) {
				//SpawnProjectile(0, "Creeper", randomFacingAngle, 0, 0, 1.0, tid);
				Spawn("Creeper", x, y, z+zOffset, tempTID, randomFacingAngle);			
			}
			else 
			{
				if (g_dayState == DAYSTATE_NIGHT) {
					if (g_dayNumber % 4 == 0)
					{
						if (random(0, 100) <= 5) {
							Spawn("ZombieMancubus", x, y, z+zOffset, tempTID, randomFacingAngle);			
						} else {
							Spawn("ZombieIncarnate", x, y, z+zOffset, tempTID, randomFacingAngle);			
						}
					}
					else
					{
                        //In r15, we spawn only incarnates at night again.
                    	Spawn("ZombieIncarnate", x, y, z+zOffset, tempTID, randomFacingAngle);			

                        /* r12-ish to r14 
						if (random(0, 10) <= 3) {
							str zombie2 = getRandomZombie();
							//SpawnProjectile(0, zombie2, randomFacingAngle, 0, 0, 1.0, tempTID);
							Spawn(zombie2, x, y, z+zOffset, tempTID, randomFacingAngle);			
						} else {
							//SpawnProjectile(0, "ZombieIncarnate", randomFacingAngle, 0, 0, 1.0, tempTID);
							Spawn("ZombieIncarnate", x, y, z+zOffset, tempTID, randomFacingAngle);			
						}
                        */
					}
				} else {
					str zombie = getRandomZombie();
					Spawn(zombie, x, y, z+zOffset, tempTID, randomFacingAngle);			
				}
			}
			break;
	}	
    
    //Give the monster special dummy inventory items that determine its random behaviours for the day!
    GiveActorInventory(tempTID, "bananas", 1);
    
    //Set the TID of the spawned monster to the special one assigned to all monsters for that player.
    Thing_ChangeTID(tempTID, tid);
}

//Spawn a dog from a cluster.
//Get this gets called by the DogSpawnerProjectile when it dies.
script 204 (int type, int preserveTID)
{
	//preserveTID is used to set the TID of the spawned monster to the activator that spawned it (usually a projectile)
	//Set preserveTID to 1 for monsters, and 0 for vegetation.
	
	int tid = ActivatorTID(); //Using getActorX/Y/Z with this doesn't work for some reason,
						      // we have to use getActorX/Y/Z(0) instead.
	if (preserveTID == 0) {
		tid = 0;
	}
	int x = getActorX(0);  //Don't use tid here!
	int y = getActorY(0);
	int z = GetActorFloorZ(0); //getActorZ(0);
	
	int randomFacingAngle = random(0, 65536);

	if (preserveTID > 0) {
		//Convert the baddie TID back into the player TID
		int playerOffset = tid - BADDIES_TID_MIN;
		int playerTid = PLAYER_MIN_TID + playerOffset;
		//int tid = BADDIES_TID_MIN + playerOffset;
		//print(s:"activator TID is: ", d:tid);
		int monsterSpawnerModeForPlayer = CheckActorInventory(playerTid, "MonsterSpawnerMode");
		//TODO: UNFINISHED - not sure what I was going for here...
	}

	int zOffset = 0.0;
	

	str monster = "";
	switch (type) {
		case 0:
			monster = "DoomZDemonDog";
			break;
		case 1:
			monster = "ChoppableTree";
			break;
		case 2:
			do { 
				monster = getRandomZombie();
			} while (StringContains(monster, "Cluster"));
			break;
		case 3:
			monster = "BerryRandomizer";
            break;
		case 4:
			monster = "Crow";
            break;
	};
	
	//Log(s:"spawning... ", s:monster);

	Spawn(monster, x, y, z+zOffset, tid, randomFacingAngle);	
}

//Spawn projectiles in a 360 degree radius from the activator and give the 
//projectiles the TID of the activator.
//This is used for spawning clusters of monsters!
script 205 (int type, int numProjectiles, int speed)
{
	str projectile = "DogSpawnerProjectile";
	switch (type) {
		case 0:
			projectile = "DogSpawnerProjectile";
			break;
		case 1:
			projectile = "TreeSpawnerProjectile";
			break;
		case 2:
			projectile = "ZombieSpawnerProjectile";
			break;
	};
	
	//Log(s:"spawning... ", d:type, s:", num projectiles: ", d:numProjectiles, s:", speed: ", d:speed); 

	int shooterTid = ActivatorTID();
	Thing_ChangeTID(0, 0);
	for (int i = 0; i < numProjectiles; i++)
	{
		//Log(s:"spawning projectile ", d:i, s:" ", s:projectile);
		SpawnProjectile(0, projectile, random(0, 255), speed, 0, 0, shooterTid);		
		Delay(1);
	}
}

/*
//Monster Spawner Version 2:
script 202 (void)
{
	int kNumBadGuysPerPlayer = 10; //3
	int kMinBadGuyRadius = 512; //Min distance to player for bad guy spawning
	int kMaxBadGuyRadius = 2048; //Max distance from player for bad guy spawning

	if (g_dayState == DAYSTATE_NIGHT)
	{
		kNumBadGuysPerPlayer = 40; //12
	}

	for (int playerTid = PLAYER_MIN_TID;
		 playerTid < PLAYER_MIN_TID+PlayerCount();
		 playerTid++)
	{
		int playerOffset = playerTid - PLAYER_MIN_TID;
		int tid = BADDIES_TID_MIN + playerOffset;
		
		//Ignore spectators and pseudospectators (players who haven't respawned yet)
		if (PlayerIsSpectator(playerOffset) > 0 || PlayerIsPseudoSpec(playerOffset)) 
		{
			continue;
		}

		int playerX = GetActorX(playerTid);
		int playerY = GetActorY(playerTid);
		int playerZ = GetActorZ(playerTid);
		int monsterSpawnerModeForPlayer = CheckActorInventory(playerTid, "MonsterSpawnerMode");
		int numBadGuysAliveForPlayer = ThingCount(T_NONE, tid);
		
		//Spawn up to N bad guys within a certain radius
		//of the player.
		if ((numBadGuysAliveForPlayer < kNumBadGuysPerPlayer) &&
			(monsterSpawnerModeForPlayer != 3))
		{
			int numBaddiesToSpawn = kNumBadGuysPerPlayer - numBadGuysAliveForPlayer;

			//Spawn baddies in polar coords, within some radius
			//of the player.
			for (int i = 0; i < numBaddiesToSpawn; i++)
			{
				int herpderpangle = random(0, 65536);
				int x = random(kMinBadGuyRadius, kMaxBadGuyRadius)*sin(herpderpangle);
				int y = random(kMinBadGuyRadius, kMaxBadGuyRadius)*cos(herpderpangle);
				int z = 128;
				
				//Center the monster around the player
				x += playerX;
				y += playerY;
				z += playerZ;
				
				int randomFacingAngle = random(0, 65536);
				switch (monsterSpawnerModeForPlayer)
				{
					case 1: //Imp zone
						if (g_dayState == DAYSTATE_NIGHT) {
							Spawn("DoomZNightImp", x, y, z, tid, randomFacingAngle);
						} else {
							Spawn("DoomZImp", x, y, z, tid, randomFacingAngle);
						}
						break;
					case 2: //Ghoul zone
						if (g_dayState == DAYSTATE_NIGHT) {
							Spawn("DoomZGhoul", x, y, z, tid, randomFacingAngle);
						} else {
							Spawn("DoomZGhoul", x, y, z, tid, randomFacingAngle);
						}
						break;
					case 3: //No monsters
						break;
					case 4: //Shadow zone
						if (g_dayState == DAYSTATE_NIGHT) {
							Spawn("DoomZGhoul", x, y, z, tid, randomFacingAngle);
						} else {
							Spawn("DoomZShadow", x, y, z, tid, randomFacingAngle);
						}
						break;
					default: //0 too
						int randomSpawnType = random(1, 100);
						if (randomSpawnType % 30 == 0) {
							Spawn("Creeper", x, y, z, tid, randomFacingAngle);			
						}
						else {
							if (g_dayState == DAYSTATE_NIGHT) {
								if (random(0, 10) <= 3) {
									str zombie2 = g_dayZombies[random(0, NUM_DAYZOMBIETYPES-1)];
									Spawn(zombie2, x, y, z, tid, randomFacingAngle);
								} else {
									Spawn("ZombieIncarnate", x, y, z, tid, randomFacingAngle);
								}
							} else {
								str zombie = g_dayZombies[random(0, NUM_DAYZOMBIETYPES-1)];
								//Spawn("ZombieRevenant", x, y, 256, tid, randomFacingAngle);
								Spawn(zombie, x, y, z, tid, randomFacingAngle);
							}
						}
						break;
				}
			}
		}
	}
}
*/

function bool PlayerIsPseudoSpec (int playerOffset)
{
	int playerTid = PLAYER_MIN_TID + playerOffset;
	if (CheckActorInventory(playerTid, "PseudoSpectatorFlag") > 0)
	{
		return true;
	}
	return false;
}

function int getDayFraction (void)
{
 	int fDayFraction = FixedDiv(g_timeOfDaySeconds<<16, 
								kDayLengthSeconds<<16);
	return fDayFraction;
}

/*
 Day / night cycle 
 */
script 210 (void)
{
	//int fDayFraction = FixedDiv(g_timeOfDaySeconds<<16, 
	//							kDayLengthSeconds<<16);
	int fDayFraction = getDayFraction();
	
	//We rescale the day fraction to make the nights shorter. We do this 
	//by plugging it into a sigmoid function so that it's no longer linear.
	//Whole rescaling equation is a sigmoid:
	//	y = 0.5*(1 + (10x-5)/ (1+abs(10x-5)))
    //These next couple lines of code are the equation done in fixed point.
	//Rescaling the day fraction:
	int nightShortnessFactor = 10.0; //Higher = shorter night
	int fX = FixedMul(nightShortnessFactor, fDayFraction) - FixedDiv(nightShortnessFactor, 2.0);
	//int fX = FixedMul(10.0, fDayFraction) - 5.0;
	fDayFraction = FixedMul(0.5, (1.0 + FixedDiv(fX, 1.0+abs(fX))));
					
					
	//g_timeOfDaySeconds - the current time
	//kDayLengthSeconds - the length a day+night cycle in seconds

	//Save a convenience variable indicating whether it's
	//day or night.
	if (abs(fDayFraction-0.5) < 0.20)
	{
		//If the previous state was day, play the night time music because
		//it's night now!
		if (g_dayState == DAYSTATE_DAY) {
			musicPlayNighttime();
		}
		g_dayState = DAYSTATE_NIGHT;	
		//ChangeSky("NIGHT","NIGHT");
		//Log(s:"Night");
	}
	else {
	//if ((g_timeOfDaySeconds < (kDayLengthSeconds/4)) || 
	//	(g_timeOfDaySeconds >= (3*kDayLengthSeconds/4))) {

		//If the previous state was night, kill all the 
		//night zombies.
		if (g_dayState == DAYSTATE_NIGHT) {
			g_blockXP = true; //globally block XP so players don't get free XP for monsters dying at night
			for (int tid = BADDIES_TID_MIN; tid < BADDIES_TID_MAX; tid++)
			{
				Thing_Damage2(tid, 1000, "NoXP"); //Kill everything and don't give any XP for it (second approach. Shouldn't need the global XP lock anymore.)
				musicPlayDaytime();
			}
			g_blockXP = false; 
			
			//Spoil all the food a few minutes after sunrise:
			//ACS_ExecuteAlways(954, 0, 0);
		}
		//It's now day time!
		g_dayState = DAYSTATE_DAY;
		//ChangeSky("DAY","DAY");
	} 
						
	int iSkyTexIdx = abs((NUM_SKY_TEXTURES-1) - (FixedMul(fDayFraction, 62.0)>>16)); //62.0 is 31.0 * 2
	//Log(i:iSkyTexIdx);
	int skyTexName = strparam(s:"0-", i:iSkyTexIdx);
	ChangeSky(skyTexName,skyTexName);
	
	int sectorTag = 0;
	int lightLevel = 64.0 + FixedMul(cos(fDayFraction), 200.0); //Sums to 256.0 max
	lightLevel = (lightLevel>>16)/2 + 128; //Convert back to integer

    Light_ChangeToValue(sectorTag, lightLevel);
	
	//DoomZ2 hack :-( - Another one below too.
    Light_ChangeToValue(12, lightLevel);
    Light_ChangeToValue(13, lightLevel);
	Light_ChangeToValue(14, lightLevel);
	
	//Log(f:fDayFraction);
	int fogLevel = 255-lightLevel;
	if (fogLevel < 0) {
		fogLevel = 258; //Disables fog! :D
	}
	//Sector_SetColor(sectorTag, 255, 0, 0, 0); //last param is desaturate
	//A fade of 0,0,0 is no fog!
	//A fade of 0,0,1 is black fog!
	Sector_SetFade(sectorTag, 16, 16, 16);//fogLevel, fogLevel, fogLevel);

	//DoomZ2 hack :-(
    Sector_SetFade(12, 16, 16, 16);
    Sector_SetFade(13, 16, 16, 16);
	Sector_SetFade(14, 16, 16, 16);

    //int lightLevel = GetSectorLightLevel(sectorTag);
}

//Set the monster spawner mode for the activator.
script 220 (int monsterSpawnerMode)
{
	/* A little bit of defensive coding here. There's a weird bug
	   where (rarely) players are ending up with the wrong monster spawner mode.
	   It could be a subtle bug anywhere, including perhaps linedefs not getting
	   activated in rare cases in multiplayer.
	*/
	int playerTID = ActivatorTID();
	int playerOffset = playerTID - PLAYER_MIN_TID;	
	//Ignore spectators and pseudospectators (players who haven't respawned yet)
	if (PlayerIsSpectator(playerOffset) > 0 || PlayerIsPseudoSpec(playerOffset)) 
	{
		monsterSpawnerMode = 0; //the default mode is 0!
	}
	
	if ((monsterSpawnerMode == MONSTER_SPAWNER_MODE_OFF) &&
	    (CheckActorInventory(playerTID, "MonsterSpawnerMode") != MONSTER_SPAWNER_MODE_OFF))
	{
		HUDMessage(s:"You feel safer here..."; HUDMSG_FADEOUT, 0, 5, 0.5, 0.4, 0, 3.5);
		//Print(s:"You feel safer here...");
	}
	else if ((monsterSpawnerMode != MONSTER_SPAWNER_MODE_OFF) &&
	    (CheckActorInventory(playerTID, "MonsterSpawnerMode") == MONSTER_SPAWNER_MODE_OFF))
	{
		HUDMessage(s:"You no longer feel safe."; HUDMSG_FADEOUT, 0, 5, 0.5, 0.4, 0, 3.5);	
		//Print(s:"You no longer feel safe.");
	}
	Delay(1);
	
	//We use a dummy item in the player's inventory to indicate what
	//type of monsters the monster spawners should be generating. 
	//(it changes by biome...). The number of dummy items in the inventory
	//corresponds to the mode.
	TakeInventory("MonsterSpawnerMode", 0x7FFFFFFF);
	Delay(1); //**** Can't take inventory and give it in the same tick (possibly), from the guys in #zamapping.
	GiveInventory("MonsterSpawnerMode", monsterSpawnerMode);
	
	//HudMessage(s:"Herp derp! ", d:monsterSpawnerMode; HUDMSG_PLAIN, 0, CR_ORANGE, 0.5, 0.5, 2.0, 255);

}

//Spawn a random item at the activator. This is called when
//an LootBox is used from the player's inventory.
script 920 (void)
{
	str thingToSpawn = getLootBoxItem();
	
	if (thingToSpawn == "")
	{
		Print(s:"The box was empty.");
		terminate;
	}
	
	Spawn(thingToSpawn, GetActorX(0), GetActorY(0), GetActorZ(0)+16.0);
}

//*** Script numbers 921 - 929 are reserved for BADDIES.acs




function bool isTheRedKeyOutThereSomewhere (void)
{
	//Check if any player has the red key in their inventory.
	for (int playerTid = PLAYER_MIN_TID;
		 playerTid < PLAYER_MIN_TID+PlayerCount();
		 playerTid++)
	{
		if (CheckActorInventory(playerTid, "RedCard") > 0)
		{
			return true;
		}
	}
	
	//Check if the red key is dropped in the map somewhere
	if (ThingCountName("RedCard", 0) > 0)
	{
		return true;
	}
	
	return false;
}

/* Script 930-933 are reserved for MATH.acs */


//Move an actor slightly towards the player. This is used
//to offset construction boxes so they can snap together
//side by side.
//TODO: FINISH ME - This is not working yet.
script 934 (void)
{
	int playerTID = PLAYER_MIN_TID + PlayerNumber();
	int boxTID = 0;
	
	int x = GetActorX(boxTID) - GetActorX(playerTID);
	int y = GetActorY(boxTID) - GetActorY(playerTID);
	int mag = fdistance(playerTID, boxTID);
	
	//PrintBold(i:boxTID, s:" ", i:playerTID, s:" ", i:x);
	
	PrintBold(i:GetActorX(boxTID), s:" ", i:FixedDiv(x, mag));
	
	x = FixedMul(FixedDiv(x, mag), 16.0);
	y = FixedMul(FixedDiv(y, mag), 16.0);
	
	SetActorPosition(boxTID, 
					 GetActorX(boxTID) + x,
					 GetActorY(boxTID) + y,
					 GetActorZ(boxTID), 
					 false);
}

// CBoxDoor opening/closing script 
script 935 (int doorTID)
{
	//PrintBold(i:x, s:" ", i:y);
	//Exit_Normal(0);
	int playerTID = ActivatorTID();
	SetActivatorToTarget(0);
	//SetActorProperty(0, APROP_Gravity, false);
	
	//SetActorPosition(0, GetActorX(0), GetActorY(0),
	//				 GetActorZ(0)+(76<<16), false);
	if (SetActorState(0, "Open"))
	{
		//Make the player be the door's target so it can
		//watch until the player walks away before it closes (A_JumpIfCloser)...
		//Zandronum 2.0 maybe?
		//SetPointer(AAPTR_TARGET, playerTID);
	}
	//Fight desync
	Delay(1);
	Delay(1);
	Delay(1);
	Delay(1);
	//Delay(35*2);

	//SetActorState(0, "Closed");
	//SetActorPosition(0, GetActorX(0), GetActorY(0),
	//				 GetActorZ(0)-(76<<16), false);
	//SetActorProperty(0, APROP_Gravity, true);
}

// Mine generation
script 936 (int resourceType)
{
	int x = GetActorX(0);
	int y = GetActorY(0);
	int z = GetActorZ(0);
	int maxDist = 640.0;
    
    if (resourceType == 1)
    {
        //Silica!
        for (int i = 0; i < 2; i++)
        {
            Spawn("MinableSilica", x+random(-maxDist, maxDist), y+random(-maxDist, maxDist), z, MINE_ROCK_TID, 0);
            Spawn("MinableSilica", x+random(-maxDist, maxDist), y+random(-maxDist, maxDist), z, MINE_ROCK_TID, 0);
            Spawn("MinableSilica", x+random(-maxDist, maxDist), y+random(-maxDist, maxDist), z, MINE_ROCK_TID, 0);
            Spawn("MinableSilica", x+random(-maxDist, maxDist), y+random(-maxDist, maxDist), z, MINE_ROCK_TID, 0);
            Spawn("MinableSilica", x+random(-maxDist, maxDist), y+random(-maxDist, maxDist), z, MINE_ROCK_TID, 0);
        }
    } 
    else if (resourceType == 2)
    {
        //Iron!
        for (i = 0; i < 2; i++)
        {
            Spawn("MinableIron", x+random(-maxDist, maxDist), y+random(-maxDist, maxDist), z, MINE_ROCK_TID, 0);
            Spawn("MinableIron", x+random(-maxDist, maxDist), y+random(-maxDist, maxDist), z, MINE_ROCK_TID, 0);
            Spawn("MinableIron", x+random(-maxDist, maxDist), y+random(-maxDist, maxDist), z, MINE_ROCK_TID, 0);
            Spawn("MinableIron", x+random(-maxDist, maxDist), y+random(-maxDist, maxDist), z, MINE_ROCK_TID, 0);
            Spawn("MinableIron", x+random(-maxDist, maxDist), y+random(-maxDist, maxDist), z, MINE_ROCK_TID, 0);
        }
    }
    else 
    {
        //Stone!
        for (i = 0; i < 2; i++)
        {
            Spawn("DaggerFallThing41", x+random(-maxDist, maxDist), y+random(-maxDist, maxDist), z, MINE_ROCK_TID, 0);
            Spawn("DaggerFallThing42", x+random(-maxDist, maxDist), y+random(-maxDist, maxDist), z, MINE_ROCK_TID, 0);
            Spawn("DaggerFallThing60", x+random(-maxDist, maxDist), y+random(-maxDist, maxDist), z, MINE_ROCK_TID, 0);
            Spawn("DaggerFallThing139", x+random(-maxDist, maxDist), y+random(-maxDist, maxDist), z, MINE_ROCK_TID, 0);
            Spawn("DaggerFallThing143", x+random(-maxDist, maxDist), y+random(-maxDist, maxDist), z, MINE_ROCK_TID, 0);
        }
    }
}

//Heal trees back to their full health so regrowing works
script 937 (void)
{
	int tid = ActivatorTID();
	SetActorProperty(tid, APROP_Health, 20000);
}

//Lock construction mutex
script 938 (void)
{
	int playerTID = ActivatorTID();
	//GiveActorInventory(playerTID, "ArmorBonus", 75);
	//GiveInventory("GreenArmor", 75);

	if (CheckInventory("ConstructionMutex") > 0) {
		//ACS_Execute(933, 0, CheckInventory("ConstructionMutex"));
		SetResultValue(false);
	} else {
		//GiveActorInventory(playerTID, "ConstructionMutex", 1); <-- Not working, dunno why
		GiveInventory("ConstructionMutex", 1);
		//ACS_Execute(933, 0, CheckInventory("ConstructionMutex"));
		SetResultValue(true);
	}
}

//Release construction mutex
script 939 (int delayTics)
{
	Delay(delayTics); //Throttle the construction box placing by 10/35 seconds
	int playerTID = ActivatorTID();

	//TakeActorInventory(playerTID, "ConstructionMutex", 1);
	TakeInventory("ConstructionMutex", 1);
	//ACS_Execute(933, 0, CheckInventory("ConstructionMutex"));

	//ACS_Execute(933, 0, ActivatorTID());
	SetResultValue(true);
}

//Mr_Xerxes' simplified construction mutex
script 256 (void) {
   GiveInventory("ConstructionMutex",1);
   Delay(10);      //Delay release by 10/35 tics
   TakeInventory("ConstructionMutex",0x7FFFFFFF);
}


//Check if actor has been placed on soil. This is used
//to see if turnips have been planted on soil or not.
script 940 (void)
{
	if (CheckActorFloorTexture(0, "FLAT10") ||
		CheckActorFloorTexture(0, "ASHWALL4"))
	{
		SetResultValue(true);
	}
	else
	{
		SetResultValue(false);
	}
}

//Check if actor has been placed on soil or grass. This is used
//to see if trees have been planted on soil/grass or not.
script 941 (void)
{
	if (CheckActorFloorTexture(0, "FLAT10") ||
		CheckActorFloorTexture(0, "ASHWALL4") ||
		CheckActorFloorTexture(0, "RROCK19") ||
		CheckActorFloorTexture(0, "GRASS1"))
	{
		SetResultValue(true);
	}
	else
	{
		SetResultValue(false);
	}
}

/*
//Fire mutex (OnFire)
script 941 (void)
{
	//int playerTID = ActivatorTID();

	if (CheckInventory("OnFire") > 0) {
		SetResultValue(false);
		Log(s:"Already on fire, skipping...");
		//SetActorState(0, "Douse");
	} else {
		GiveInventory("OnFire", 1);
		SetResultValue(true);
		Log(s:"Not on fire, catching...");
	}
	//Delay(2); //Inventory sync
}

//Remove OnFire flag from master (the thing that's on fire)
//The flame actor calls this when it burns out.
script 942 (void)
{
	//int oldTid = ActivatorTID();
	//int master = UniqueTID(SAFE_UNIQUE_TID_MIN);
	//Thing_ChangeTID(0, );
	//int masterTID = UniqueTID(SAFE_UNIQUE_TID_MIN);
	SetActivator(0);//, AAPTR_MASTER);
	TakeInventory("OnFire", 0x7FFFFFFF);
	SetActorState(0, "Grow");
}*/

/* script 950-959 are reserved for tutorial.acs */


//From GZDoomBuilder's commonFuncs.h 
/* XXX: Use UniqueTID instead!
function int unusedTID(int start, int end)
{
    int ret = start - 1;
    int tidNum;

    if (start > end) { start ^= end; end ^= start; start ^= end; }  // good ol' XOR swap
    
    while (ret++ != end)
    {
        if (ThingCount(0, ret) == 0)
        {
            return ret;
        }
    }
    
    return -1;
}
*/

//int lastPlayerBoatActivator = 0;

//Raft script
script 943 (void)
{
/* Old approach where player is the activator to begin with (USESPECIAL or BUMPSPECIAL),
   and then we get the boat TID by getting the 

	//Don't allow this button to be pressed if you're spectating
	int playerTID = ActivatorTID();
	int playerOffset = playerTID - PLAYER_MIN_TID;	
	if (PlayerIsSpectator(playerOffset) > 0 || PlayerIsPseudoSpec(playerOffset))
	{
		terminate;
	}
	//Needed for when the special gets called when a crafting box dies.
	if ( CheckInventory("Health")<=0 )
	{
		terminate;
	}
	

	//If the activator is not a player (like when the box itself dies),
	//just return. NOTE: This is actually not used because of ActivateOwnDeathSpecials in MAPINFO.
	if (PlayerNumber() < 0) {
		Log(s:"Non-player activator!");
		//terminate;
	}
	
	//The current activator is usually the player, so this next line will make the 
	//player's target the new activator.
	SetActivatorToTarget(0);
	
	//If the player is still the activator, then that means the player didn't have
	//the boat under their crosshairs when they activated it.
	if (PlayerNumber() >= 0) {
		Log(s:"Try pointing at the edge of the boat to activate it!");
		terminate;
	}
*/

	//NEW
	int boatTid = ActivatorTID();
	
	if (boatTid == 0) {
		boatTid = UniqueTID(SAFE_UNIQUE_TID_MIN, SAFE_UNIQUE_TID_MAX-SAFE_UNIQUE_TID_MIN);
		Thing_ChangeTID(0, boatTid);
	}
	//Log(s:"Raft TID:", d:boatTid);

	//NEW
	SetActivatorToTarget(boatTid);
	int playerTID = ActivatorTID();

	ThingSound(playerTID, "click", 127);

	if (GetActorVelY(boatTid) > 0)
	{
		//Log(s:"Raft already started. Aborting.");
		//terminate;
	}

/*
	if (CheckActorInventory(boatTid, "PlatformDirection") > 0) {
		//SetActorState(boatTid, "MoveBackwards");
		TakeActorInventory(boatTid, "PlatformDirection", 0x7FFFFFFF);
		Delay(1);
		GiveActorInventory(boatTid, "PlatformDirection", 2);
	} else {
		//SetActorState(boatTid, "Move");
		TakeActorInventory(boatTid, "PlatformDirection", 0x7FFFFFFF);
		Delay(1);
		GiveActorInventory(boatTid, "PlatformDirection", 1);
		Delay(1);
	}
*/

	//Alternative mode: Freezing the player to the boat.
	//SetActorProperty(playerTID, APROP_Speed, 0);
	
	int kBoatRadius = 120.0;
	int kBoatHeight = 16.0;
	
	SetActorPosition(playerTID, GetActorX(boatTid), GetActorY(boatTid), GetActorZ(boatTid)+kBoatHeight, false);

	while (true)
	{
		for (int i = PLAYER_MIN_TID; i < PLAYER_MIN_TID+PlayerCount(); i++)
		{
			if ((abs(GetActorX(boatTid)-GetActorX(i)) <= kBoatRadius) && 
				(abs(GetActorY(boatTid)-GetActorY(i)) <= kBoatRadius)) //no APROP_Radius until Zandro 2.0? :-(
			{
				//SetActorVelocity(i, 0.0, FixedDiv(GetActorVelY(boatTid), 1.6), 0, false, false);
				SetActorVelocity(i, 0.0, FixedDiv(GetActorVelY(boatTid), 1.4), 0, true, false);
				//SetActorVelocity(i, 0.0, GetActorVelY(boatTid), 0, true, false);
			}
		}
		//Alternative mode: Freezing the player to the boat.
		//SetActorPosition(playerTID, GetActorX(boatTid), GetActorY(boatTid), GetActorZ(boatTid)+4.0, false);
		Delay(8);
	}
}

script 944 (int playerTID)
{
	SetActivatorToTarget(playerTID);
	//Thing_Remove(GetActivatorTID());
}


//Boat script
//Totally not finished yet. Check out the raft script above (and DECORATE.RAFT) if you want to 
//see how I made the hell raft in the doomz2 map.
script 945 (void) 
{
    int boatTID = ActivatorTID();
    SetActivatorToTarget(boatTID);

    int playerTID = ActivatorTID();
    
    Log(s:"Boat TID:", d:boatTID);
    Log(s:"Player TID:", d:playerTID);

    //XXX: ALBERT UNCOMMENT THIS
	//int playerTID = ActivatorTID();
    
	int playerOffset = playerTID - PLAYER_MIN_TID;	
	if (PlayerIsSpectator(playerOffset) > 0 || PlayerIsPseudoSpec(playerOffset))
	{
		terminate;
	}
	
	//Needed for when the special gets called when a crafting box dies.
	if ( CheckInventory("Health")<=0 )
	{
		terminate;
	}
	
	//If the activator is not a player (like when the box itself dies),
	//just return. NOTE: This is actually not used because of ActivateOwnDeathSpecials in MAPINFO.
	if (PlayerNumber() < 0) {
		terminate;
	}

	//Prevent each spacebar press from re-activating the boat
	if (GetActorProperty(0, APROP_Speed) == 0) {	
		terminate;
	}
	/*
	//NEW
	int boatTid = ActivatorTID();
	
	if (boatTid == 0) {
		boatTid = UniqueTID(SAFE_UNIQUE_TID_MIN, SAFE_UNIQUE_TID_MAX-SAFE_UNIQUE_TID_MIN);
		Thing_ChangeTID(0, boatTid);
	}
	Log(s:"Boat TID:", d:boatTid);

	//NEW
	SetActivatorToTarget(boatTid);
	int playerTID = ActivatorTID();
	*/
	
    //XXX: ALBERT UNCOMMENT THIS
	//SetActivatorToTarget(0);
    SetActivator(boatTID); //temporary
    
	//log(d:targetTid);
	if (PlayerNumber() >= 0) {
		Print(s:"Try pointing at the side of the boat to activate it!");
		//ACS_Execute(751, 0, 0);
		terminate;
	}
    
    //XXX: ALBERT UNCOMMENT THIS
	//int boatTID = ActivatorTID();
    
    //int boatTID = GetActorProperty(playerTID, APROP_TargetTID);
    //if (boatTID == 0) {
    //    terminate;
    //}
	    
	//Set the activator back to being the player
	SetActivator(playerTID);
	
	ThingSound(playerTID, "click", 127);

	if (GetActorVelY(boatTid) > 0)
	{
		Log(s:"Boat already started. Aborting.");
		terminate;
	}

    //If the boat is flipped, right itself before the player gets on.
    if (GetUserVariable(boatTid, "user_flipped") == true) {
        SetActorState(boatTid, "RightItself");
        Delay(80);
    }
    
    
	int kBoatRadius = 120.0;
	int kBoatHeight = 16.5;

	//Alternative mode: Freezing the player to the boat.
	SetActorPosition(playerTID, GetActorX(boatTid), GetActorY(boatTid), GetActorZ(boatTid)+kBoatHeight, false);
	int oldPlayerSpeed = GetActorProperty(playerTID, APROP_Speed);
	SetActorProperty(playerTID, APROP_Speed, 0);
	
    int prevPlayerAngle = GetActorAngle(playerTID);
    int prevBoatAngle = GetActorAngle(boatTid);
    int playerRotations = 0;
    int boatRotations = 0;
   
    int lastDotProd = 0;   
    
	while (true)
	{
		/*
		for (int i = PLAYER_MIN_TID; i < PLAYER_MIN_TID+PlayerCount(); i++)
		{
			if ((abs(GetActorX(boatTid)-GetActorX(i)) <= kBoatRadius) && 
				(abs(GetActorY(boatTid)-GetActorY(i)) <= kBoatRadius)) //no APROP_Radius until Zandro 2.0? :-(
			{
				//SetActorVelocity(i, 0.0, FixedDiv(GetActorVelY(boatTid), 1.6), 0, false, false);
				SetActorVelocity(i, 0.0, FixedDiv(GetActorVelY(boatTid), 1.4), 0, true, false);
				//SetActorVelocity(i, 0.0, GetActorVelY(boatTid), 0, true, false);
			}
		}*/

        //Original behaviour: Always point the boat in the direction of the player.
		//SetActorAngle(boatTid, GetActorAngle(playerTid));
		
        
        //New behaviour: Only rotate boat when paddling.
        if (GetActorVelX(boatTid) != 0 || GetActorVelY(boatTid) != 0)
        {
            int playerAngle = GetActorAngle(playerTid);
            int boatAngle = GetActorAngle(boatTid);
            
            if (prevPlayerAngle > 0.9 && playerAngle < 0.1) {
                playerRotations++;
            } else if (prevPlayerAngle < 0.1 && playerAngle > 0.9) {
                playerRotations--;
            }
		
            if (prevBoatAngle > 0.9 && boatAngle < 0.1) {
                boatRotations++;
            } else if (prevBoatAngle < 0.1 && boatAngle > 0.9) {
                boatRotations--;
            }
        
            //Save this so we can count playerRotations
            prevPlayerAngle = playerAngle;
            prevBoatAngle = boatAngle;
            
            int boatAngleUncorrected = boatAngle;

            playerAngle += (FixedMul(playerRotations<<16, 1.0));
            boatAngle += (FixedMul(boatRotations<<16, 1.0));
            //Log(s:"PAngle: ", f:playerAngle, s:", Rotations: ", d:playerRotations);

            int deltaAngle = playerAngle - boatAngle;
            int deltaAngleToRotate = 0;
            int MAX_ROTATION_SPEED = 0.001;
            
            //Log(s:"Delta Angle: ", f:deltaAngle);
            
            if (GetUserVariable(boatTID, "user_justpaddled") == 1)
            {
                Log(s:"Just paddled");
                SetUserVariable(boatTID, "user_justpaddled", 0);
                if (deltaAngle > 0.25 || deltaAngle < -0.25) {
                    Log(s:"Reversing direction...");
                    SetUserVariable(boatTID, "user_direction", 128);
                } else {
                    Log(s:"Normalizing direction...");
                    SetUserVariable(boatTID, "user_direction", 0);
                }
            }
            
            //Offset the angle to rotate to if the user is facing backwards.
            deltaAngle -= FixedDiv(GetUserVariable(boatTID, "user_direction"),256);

            int boatVelX = GetActorVelX(boatTid); //Not quite fixed point
            int boatVelY = GetActorVelY(boatTid);
            //int boatSpeed = VectorLength(boatVelX, boatVelY);
            
            int boatSpeed = 0;
            int ang = vectorangle(boatVelX,boatVelY);
            if(((ang+0.125)%0.5) > 0.25) boatSpeed = fixeddiv(boatVelY, sin(ang));
            else boatSpeed = fixeddiv(boatVelX, cos(ang));

            //FixedSqrt(FixedMul(boatVelX, boatVelX) + FixedMul(boatVelY, boatVelY));
            //Log(s:"Boat speed:", f:boatVelX, s:" ", f:boatVelY, s:" ", f:boatSpeed);
                    
            //Allow the player to steer faster when using the paddle altfire.
            if (CheckActorInventory(playerTID, "PaddleSteer") >= 1) {
                MAX_ROTATION_SPEED = 0.005;
                if (boatSpeed < 4.0) {
                    MAX_ROTATION_SPEED = FixedDiv(MAX_ROTATION_SPEED, 8.0-boatSpeed*2);
                    //Log(f:MAX_ROTATION_SPEED);
                }
            }
            
            if (deltaAngle > 0) {
                deltaAngleToRotate = math_min(FixedMul(deltaAngle, 0.05), MAX_ROTATION_SPEED);
            } else {
                deltaAngleToRotate = math_max(FixedMul(deltaAngle, 0.05), -MAX_ROTATION_SPEED);            
            }
            SetActorAngle(boatTid, boatAngle + deltaAngleToRotate);
            
            //Flip your boat over if the direction of its velocity vector
            //differs too much from its heading. (dot product nears 0)
            int boatHeadingX = cos(boatAngleUncorrected);
            int boatHeadingY = sin(boatAngleUncorrected);
            int boatHeadingMag = 1; // boatHeadingMag is 1 by defintion
 
            //Normalize them:
            int boatVelNormX = FixedDiv(boatVelX, boatSpeed);
            int boatVelNormY = FixedDiv(boatVelY, boatSpeed);
            
            //Distance from http://zdoom.org/wiki/Distance
            //VectorLength isn't working for some reason.

            
            int dotProd = FixedMul(boatVelNormX, boatHeadingX) + FixedMul(boatVelNormY, boatHeadingY);

            int velocityAngle = VectorAngle(boatVelNormX, boatVelNormY);
            int angleBetweenVelAndDir = (boatAngleUncorrected - velocityAngle);
            
            //Useful for debugging the capsizing logic:
            //Log(s:"Angle: ", f:angleBetweenVelAndDir);
            
            //Log(s:" ", f:dotProd, s:" ", f:boatSpeed,
            //    s:" ", f:boatVelNormX, s:" ", f:boatVelNormY);

            //Log(s:"Dot prod: ", f:dotProd);
            
            
            //We have to check lastDotProd too because your velocity can
            //be instantaneously very high when you paddle and you're directly
            //stuck against a wall. The test case is paddling directly into a wall from standstill.
            
            if (((dotProd > 0 && dotProd < 0.05) || dotProd < 0 && dotProd > -0.05 ) &&
                ((lastDotProd > 0 && lastDotProd < 0.05) || lastDotProd < 0 && lastDotProd > -0.05 ) &&
                (abs(boatVelX) > 6.0 || abs(boatVelY) > 6.0)) {
                SetActorState(boatTID, "Flip");
                PlaySound(playerTID, "player/male/land1");
                
                //Launch the player out of the boat
                SetActorProperty(playerTID, APROP_Speed, oldPlayerSpeed);
                SetActorVelocity(playerTID, -16.0, 0, 6.0, true, true);
                
                //Point the boat in the direction of its velocity.
                int angleIncrement = angleBetweenVelAndDir / 10;
                for (int i = 0; i < 10; i++) {
                    SetActorAngle(boatTid, boatAngleUncorrected + i*angleIncrement);
                    Delay(3);
                }
                
                terminate;		   
            }
            
            lastDotProd = dotProd;

        }

                
        //SetActorVelocity(boatTid, 
        int boatStillExists = (ClassifyActor(boatTid) != 0);
        
        if (boatStillExists)
		{
            //Alternative mode: Freezing the player to the boat.
            SetActorPosition(playerTID, GetActorX(boatTid), GetActorY(boatTid), GetActorZ(boatTid)+kBoatHeight, false);
        }
			
        Delay(1);
            
		int buttons = GetPlayerInput(-1, INPUT_BUTTONS);

		//Exit if you hit the jump button
		if (buttons & BT_JUMP || !boatStillExists)
		{
			//buttonDepressed = true;
			//print(d: selectedItemIdx);
			//Delay(1);
			//ACS_ExecuteAlways(751, 0);
			ActivatorSound("click", 127);
			SetActorProperty(playerTID, APROP_Speed, oldPlayerSpeed);
			terminate;		   
		}
	}
}

//Print debug (all players)
script 946 (int x, int y, int z)
{
	PrintBold(s:"DEBUG:", d:x, s:" ", d:y, s:" ", d:z);
	PrintBold(s:"DEBUG: Activator TID: ", d:ActivatorTID());
}

//Spawn a new tree after some random delay
//FIXME: Try again with Zandronum 2.0.
script 947 (void)
{
	//Delay(35);
	//FIXME: This line always returns 0 (or string 0)
	int foo = GetActorProperty(ActivatorTID(), APROP_NameTag);
	Log(s:"Spawning:", d:foo);
	Log(s:"at:", d:GetActorX(0));
	//Spawn(GetActorProperty(0, APROP_NameTag), 0, 0, 16.0);
	Spawn("DaggerFallThing53", GetActorX(0), GetActorY(0), GetActorZ(0)+16.0);
}

//Chicken lay egg script. Caps the number of eggs!
script 948 (void)
{
	int MAX_CHICKENS = 40;
	int numChickens = ThingCountName("DoomZChicken", 0);
	if (numChickens >= MAX_CHICKENS) {
		terminate;
	}
	
	//Lower the probability of actually laying an egg (linearly) as the number 
	//of chickens grows toward the max number of chicknes.
	if (random(0, MAX_CHICKENS) > numChickens)
	{
		Spawn("DoomZEgg", GetActorX(0), GetActorY(0), GetActorZ(0));
	}
}

//Use an ammo box
script 949 (int ammoType)
{
	switch(ammoType)
	{
		case 0:
			UseInventory("DoomZShellBoxItem");
			break;
		default:
			Print(s:"Unknown ammo type in script 949");
			break;
	}
}

int gridSize = 4096.0;
int kVegDisappearDistance = 2896.5; // sqrt(2*gridSize*gridSize)

script 950 ENTER CLIENTSIDE
{
    //Only run for the local player!
    //If we don't do this, it'll run once per player, and never terminates, so any player rejoining from spectating causes it to run again!
    if (PlayerNumber() != ConsolePlayerNumber()) {
        terminate;
    }
    
	while (true)
	{   
		int playerTID = ActivatorTID();
		int playerX = GetActorX(playerTID);
		int playerY = GetActorY(playerTID);
		
		int MAX_VEGETATION_COUNT = 1024; //Per quadrant
		int currentVegCount = ThingCount(T_NONE, VEGETATION_TID);
		int numVeggiesToGenerate = MAX_VEGETATION_COUNT - currentVegCount;

		int gridCellSpacing = 256.0;
		int gridCellCountWide = 16;
        
        //Sanity check
        if (PlayerIsSpectator(ConsolePlayerNumber())) {
            terminate;
        }
        
        if (!g_vegetationEnabled) {
            //Reset vegetation
            Thing_Remove(VEGETATION_TID);
            Delay(8);
            continue;
        }
		
		//The vegetation is generated on a square grid. This grid is populated with cells,
		//with a plant on each cell vertex. The origin of the grid is shifted such that the
		//the player is always at the center of the grid.
		int vegGridOriginX = playerX - gridSize/2; //- (playerX % gridSize);
		int vegGridOriginY = playerY - gridSize/2; //- (playerY % gridSize);

		for (int i = 0; i < MAX_VEGETATION_COUNT; i++)
		{
			int vegX = vegGridOriginX + (i%gridCellCountWide)*gridCellSpacing;
			int vegY = vegGridOriginY + (i/gridCellCountWide)*gridCellSpacing;
			
			//Snap to a second coordinate grid, which serve as the input variables for the 
			//procedural generation (vegetation type, position deviation, etc.)
			vegX -= (vegX % gridCellSpacing);
			vegY -= (vegY % gridCellSpacing);
			
			//Deterministic RNG code from Mathias Byens: https://gist.github.com/mathiasbynens/5670917
			int seed = (vegX+vegX) - (vegY+vegY);
			// Robert Jenkins’ 32 bit integer hash function
			seed = ((seed + 0x7ED55D16) + (seed << 12))  & 0xFFFFFFFF;
			seed = ((seed ^ 0xC761C23C) ^ (seed >> 19)) & 0xFFFFFFFF;
			seed = ((seed + 0x165667B1) + (seed << 5))   & 0xFFFFFFFF;
			seed = ((seed + 0xD3A2646C) ^ (seed << 9))   & 0xFFFFFFFF;
			seed = ((seed + 0xFD7046C5) + (seed << 3))   & 0xFFFFFFFF;
			seed = ((seed ^ 0xB55A4F09) ^ (seed >> 16)) & 0xFFFFFFFF;
			int w1 = FixedDiv(seed & 0xFFFFFFF, 0x10000000);

			seed = (vegX + vegX) + (vegY + vegY);
			seed = ((seed + 0x7ED55D16) + (seed << 12))  & 0xFFFFFFFF;
			seed = ((seed ^ 0xC761C23C) ^ (seed >> 19)) & 0xFFFFFFFF;
			seed = ((seed + 0x165667B1) + (seed << 5))   & 0xFFFFFFFF;
			seed = ((seed + 0xD3A2646C) ^ (seed << 9))   & 0xFFFFFFFF;
			seed = ((seed + 0xFD7046C5) + (seed << 3))   & 0xFFFFFFFF;
			seed = ((seed ^ 0xB55A4F09) ^ (seed >> 16)) & 0xFFFFFFFF;
			int w2 = FixedDiv(seed & 0xFFFFFFF, 0x10000000); // / 0x10000000;

			
			//TODO: Calculate vegation variant based off seed!
			
			int variant = ((FixedMul(w1, 4.0) + 0.5) >> 16); //rounded - 0 to 4
		
			//2D waves! Could be useful as ocean wave generator!!!
			//vegX += FixedMul(256.0, sin(FixedDiv(vegX % gridSize, gridSize)));
			//vegY += FixedMul(256.0, cos(FixedDiv(vegY % gridSize, gridSize)));


			//Spawn it with a temporary TID and drop it to the floor.
			int tempTID = VEGETATION_TID + 1;

			vegX += FixedMul(w1 - 0.5, 256.0);
			vegY += FixedMul(w2 - 0.5, 256.0);
			
			//Dummy actor so we can check the floor texture:
			Spawn("DaggerfallThing1", vegX, vegY, GetActorCeilingZ(playerTID)-256.0, tempTID);
			
			int floorZ = GetActorFloorZ(tempTID);
			
			//The game freaks out and +DONTOVERLAP doesn't work correctly
			//when we're outside the limits floating point precision limits of the
			//Doom engine. The position comparison of the engine fails due to precision problems.
			if (vegX > 9400.0 || vegY > 9400.0) {
				Thing_Remove(tempTID);
			}
			if (vegX < -9400.0 || vegY < -9400.0) {
				Thing_Remove(tempTID);
			}
			
			if (CheckActorFloorTexture(tempTID, "FLAT10") ||
				CheckActorFloorTexture(tempTID, "ASHWALL4"))
			{
				Thing_Remove(tempTID);

				str vegClass = "ProceduralGrass1";
				if (variant == 0) {
					vegClass = "ProceduralGrass2";
				} else if (variant == 1) {
					vegClass = "ProceduralGrass3";
				} else if (variant == 2) {
					vegClass = "ProceduralGrass4";
				} else if (variant == 3) {
					vegClass = "ProceduralGrass5";
				} else if (variant == 4) {
					vegClass = "ProceduralGrass6";
				} else if (variant == 5) {
					vegClass = "ProceduralGrass7";
				} else if (variant == 6) {
					vegClass = "ProceduralGrass8";
				} else if (variant == 7) {
					vegClass = "ProceduralGrass9";
				}
				/*
				} else if (variant == 8) {
					vegClass = "ProceduralGrass2";
				} else if (variant == 9) {
					vegClass = "ProceduralGrass2";
				} else {
					vegClass = "ProceduralGrass2";
				}					*/
				if (!Spawn(vegClass, vegX, vegY, floorZ, tempTID)) {
					//Log(s:"spawn failed ", d:i);
					continue;
				}
				
				 //Line of sight check to ensure it's inside the map
				 /*
				if (!ACS_ExecuteWithResult(958, playerTID, tempTID))
				{
					Thing_Remove(tempTID);
					continue;
				}*/

				//We use the actor's score to store the player TID
				SetActorProperty(tempTID, APROP_SCORE, playerTID);
				Thing_ChangeTID(tempTID, VEGETATION_TID);
				
			} else {
				Thing_Remove(tempTID);
			}
		}

		Delay(8);
	}
}

//Distance check for procedural vegetation
script 951 (int playerTID) 
{
	//See also script 958!!!
	
	//TODO: Need to 
	if (fdistance(0, playerTID) > kVegDisappearDistance) { // 5793.0 2896.3 //sqrt(2*gridSize*gridSize)
		SetActorState(0, "Death");
	}
}

//Check if the actor is on water. Used by the water bucket.
script 952 (int playerTID)
{
	int hitWater = CheckActorFloorTexture(0, "FWATER1")  || 
					CheckActorFloorTexture(0, "FWATER2") ||
					CheckActorFloorTexture(0, "FWATER3") ||
					CheckActorFloorTexture(0, "FWATER4");
		
	//Since this function is being called from a projectile, 
	//we can set the activator back to the player by calling this like so:
	//Reference: http://zdoom.org/wiki/SetActivatorToTarget
	SetActivatorToTarget(0);
	
	//SetActivator(playerTID);
	//Now the player is the activator.
	
	if (hitWater) {
		GiveInventory("WaterAmmo", 10);
		SetResultValue(true);
	} else {
		SetResultValue(false);
	}
}

/* Called by food when it spawns. Set the TID of an actor to be the food TID. 
   This is how we make all the food on a map spoil.
*/ 
script 953 (void)
{
	Thing_ChangeTID(0, FOOD_TID);
}

//Spoil all the food on the map after a 1 minute delay.
script 954 (void)
{
	Delay(35*60);
	
	//Remove all food on the ground
	Thing_Remove(FOOD_TID);
	
	//Remove all food from every player's inventory
	for (int playerTid = PLAYER_MIN_TID;
		 playerTid < PLAYER_MIN_TID+PlayerCount();
		 playerTid++)
	{
		int playerOffset = playerTid - PLAYER_MIN_TID;
		TakeActorInventory(playerTid, "CookedChicken", 0x7FFFFFFF);
		TakeActorInventory(playerTid, "Turnip", 0x7FFFFFFF);		
		TakeActorInventory(playerTid, "CranberryItem", 0x7FFFFFFF);		
		TakeActorInventory(playerTid, "BlueberryItem", 0x7FFFFFFF);		
		TakeActorInventory(playerTid, "StrawberryItem", 0x7FFFFFFF);
	}
	
	PrintBold(s:"Any food you had has spoiled.");
}


//Summon Death to follow the player since they died of hunger.
//The player must get an Ankh an use it to stop Death.
script 955 (void)
{
	int playerTid = ActivatorTID();
	int playerOffset = playerTid - PLAYER_MIN_TID;
	int deathTID = DEATH_TID_MIN + playerOffset;
	int ankhTID = ANKH_TID_MIN + playerOffset;
	
	//If there already is a death actor roaming the map for this player, return.
	if (ThingCount(T_NONE, deathTID) > 0) {
		Thing_Hate(deathTID, playerTID, 5); //Hunt and attack the player
		terminate;
	}
	
	Print(s:"Death is now stalking you...");
	SpawnForced("DoomZDeath", GetActorX(playerTid)+512.0, GetActorY(playerTid)+512.0, getActorZ(playerTid), deathTID, 0);
	Thing_Hate(deathTID, playerTID, 5); //Hunt and attack the player
	
	Delay(160);
	Print(s:"Find the Ankh to cheat death!");
	
	//Summon the ankh at a random easy questspot on the map:
	
	if (CheckActorInventory(playerTid, "Ankh") > 0) { //Unless the player already has an ankh somehow (shouldn't happen...)
		terminate;
	}
	
	int questSpotTID = getRandomEasyQuestSpotTID();
	
	SpawnForced("Ankh", GetActorX(questSpotTID), GetActorY(questSpotTID), GetActorZ(questSpotTID), ankhTID, 0);
	
}

function int getRandomEasyQuestSpotTID(void)
{
	int numEasyQuestSpotsOnMap = countQuestSpots(MIN_EASYQUESTSPOT_TID, MAX_EASYQUESTSPOT_TID);
	int questSpotTID = random(MIN_EASYQUESTSPOT_TID, MIN_EASYQUESTSPOT_TID + numEasyQuestSpotsOnMap - 1);
	return questSpotTID;
}

//Called by the Ankh of Life when it's used. Kills the Death actor chasing the player
//after they die of hunger and removes the curse.
script 956 (void)
{
	int playerTid = ActivatorTID();
	int playerOffset = playerTid - PLAYER_MIN_TID;
	int deathTID = DEATH_TID_MIN + playerOffset;

	//If there is no death actor roaming the map for this player, return.
	//if (ThingCount(T_NONE, deathTID) == 0) {
	if (CheckInventory("DeathCurse") <= 0) {
		SetResultValue(0);
		terminate;
	}

	
	//Play the cure music
	LocalAmbientSound("ankhcure", 127);

	SetActorProperty(playerTid, APROP_Invulnerable, 1);
	int oldSpeed = GetActorProperty(0, APROP_Speed);
	int oldMass = GetActorProperty(0, APROP_Mass);
	SetActorProperty(playerTid, APROP_Speed, 0);
	SetActorProperty(playerTid, APROP_Mass, 0x7FFFFFFF);

	FadeTo(255, 255, 255, 1.0, 3.0);
	Radius_Quake(4, 35, 0, 4, 0);
	Delay(35*1);
	Radius_Quake(6, 35, 0, 4, 0);
	Delay(35*1);
	Radius_Quake(9, 35, 0, 4, 0);
	Delay(35*1);
	FadeTo(0, 0, 0, 1.0, 2.0);
	Delay(35*2);
	
	Thing_Destroy(deathTID, 1);
	TakeActorInventory(playerTid, "DeathCurse", 0x7FFFFFFF);
	TakeActorInventory(playerTid, "HungerLevel", 0x7FFFFFFF);


	Delay(35*3);

	FadeTo(0, 0, 0, 0.0, 1.0);
	Delay(35*1);
	
	for (int angle = 0; angle < 255; angle += 255/10) {
		SpawnProjectile(playerTid, "CreeperExplosion", angle, 80, 0, 0, 0);
	}
	
	Delay(45);
	SetActorProperty(playerTid, APROP_Invulnerable, 0);
	SetActorProperty(playerTid, APROP_Speed, oldSpeed);
	SetActorProperty(playerTid, APROP_Mass, oldMass);

	//Play the quest completed music.
	//ACS_ExecuteAlways(117, 0, 0);
	Print(s:"You have defeated death!");
}

script 957 (void) 
{
	int playerTid = ActivatorTID();
	int hasDeathCurse = (CheckInventory("DeathCurse") > 0);
	SetResultValue(hasDeathCurse);
}

//Line of sight check for procedural vegetation system - Used by the vegetation
//to test if they spawned outside the map or not.
script 958 (int playerTID)
{
	if (!CheckSight(0, playerTID, CSF_NOBLOCKALL | CSF_NOFAKEFLOORS)) {
		SetActorState(0, "Death");
	}
}


//Inventory guardian activation script.
//Deactivating the shield is only allowed if you were the one who dropped the guardian
script 960 (void)
{
	//If the activator is not a player (like when the box itself dies),
	//just return. NOTE: This is actually not used because of ActivateOwnDeathSpecials in MAPINFO.
	if (PlayerNumber() < 0) {
		terminate;
	}	

	//Don't allow this button to be pressed if you're spectating
	int playerTID = ActivatorTID();
	if (PlayerIsSpectator(PlayerNumber()) > 0 || PlayerIsPseudoSpec(PlayerNumber()))
	{
		terminate;
	}
	
	//Needed for when the special gets called when a crafting box dies.
	if ( CheckInventory("Health")<=0 )
	{
		terminate;
	}

	//Get the guardian TID
	SetActivatorToTarget(0);
	
	if (PlayerNumber() >= 0) {
		//Log(s:"Try pointing at the side of the inventory guardian to deactivate it!");
		terminate;
	}

	int guardianTID = ActivatorTID();
	
	if (playerTID == GetActorProperty(guardianTID, APROP_Score)) {
		//Thing_Remove(guardianTID);
		SetActorState(guardianTID, "Death");
	} else {
		SetActivator(playerTID);
		int guardOwnerPlayerNum = GetActorProperty(guardianTID, APROP_Score) - PLAYER_MIN_TID;
		Print(s:"This inventory guard can only be deactivated by ", n:(guardOwnerPlayerNum+1));
	}
}

//Inventory guardian spawn script.
//This gets called when a player dies and they have it in their inventory.
//We need to use a script to associate the guardian with the player.
script 961 (int playerTID)
{
    Log(s:"Inventory guard script! ", d:CheckActorInventory(playerTID, "InventoryGuardItem"));
	if (CheckActorInventory(playerTID, "InventoryGuardItem") <= 0) {
		terminate;
	}
	//TakeActorInventory(playerTID, "InventoryGuardItem", 1);
	
	int tempTID = UniqueTID(SAFE_UNIQUE_TID_MIN);
	int angle = GetActorAngle(playerTID);
	int radius = 0.0; //88.0; //Your inventory seems to drop 88 units in front of you when you die.
	SpawnForced("InventoryGuard", 
				GetActorX(playerTID) + FixedMul(radius, cos(angle)), 
				GetActorY(playerTID) + FixedMul(radius, sin(angle)), 
				GetActorZ(playerTID), 
				tempTID, 0);
	SetActorProperty(tempTID, APROP_Score, playerTID);
	int playerVelX = GetActorVelX(playerTID);
	int playerVelY = GetActorVelY(playerTID);
	int playerVelZ = GetActorVelZ(playerTID);
	SetActorVelocity(tempTID, playerVelX, playerVelY, playerVelZ, false, false);
	
	Thing_ChangeTID(tempTID, 0);
	
}


//Berry spawner script
script 962 OPEN
{

	int questSpotTID = -1;
	
	//Spawn some berry plants to initialize the world:
	for (int i = 0; i < BASE_BERRY_PLANTS; i++)
	{
		questSpotTID = getRandomEasyQuestSpotTID();
		SpawnProjectile(questSpotTID, "BerrySpawnerProjectile", random(0, 255), 50, 0, 1, 0);
	}
	
	//Calculate 
	int BERRY_PLAYER_SCALING = 2; //This works pretty well and gives nice integer numbers in the calculation below.
	int MAX_BERRY_PLANTS_SCALED = ((PlayerCount()-1)*BASE_BERRY_PLANTS)/BERRY_PLAYER_SCALING + BASE_BERRY_PLANTS;

	//Every N seconds, we pick a random easy quest spot and shoot some berry spawner projectiles 
	//out of it to spawn berries around it. We also put all plants into this "MaybeDie" state
	//if there's too many of them, which randomly kills off 5% of them. This prevents the plants
	//from all becoming bunched up in part of the map you never visit.
	while(true) {
		
		//print(d:ThingCount(T_NONE, BERRY_PLANT_TID));
		while (ThingCount(T_NONE, BERRY_PLANT_TID) > MAX_BERRY_PLANTS_SCALED) {
			SetActorState(BERRY_PLANT_TID, "MaybeDie");
			Delay(2);
		};
		
		//Spawn a bunch of berries to get us back up to the max amount.
		//Note that in practice, some of these might land on other actors and won't spawn.
		int numBerryPlantsNow = ThingCount(T_NONE, BERRY_PLANT_TID);
		for (i = 0; i < MAX_BERRY_PLANTS_SCALED - numBerryPlantsNow; i++) {
			questSpotTID = getRandomEasyQuestSpotTID();
			SpawnProjectile(questSpotTID, "BerrySpawnerProjectile", random(0, 255), 50, 0, 1, 0);
		}

        Delay(BERRY_SPAWNER_INTERVAL_SECONDS*35);
	};
}

//Set the activator to have the berry plant TID.
script 963 (void)
{
	Thing_ChangeTID(0, BERRY_PLANT_TID);
}


/* Obelisk activation script */
script 964 (int bossSpawnSpotTID) //Can only have one parameter in practice because Thing_SetSpecial only has one from DECORATE
{
    int playerTID = ActivatorTID();

    if (!SetActivatorToTarget(0)) {
        terminate;
    }
    
    //The activator is the obelisk now.
    
    //GiveActorInventory(playerTID, "Berserk", 1);
    
    int sectorFloorLowerTag = bossSpawnSpotTID;
    
    int bossTID = UniqueTID(SAFE_UNIQUE_TID_MIN);
    
    if (CheckActorClass(0, "IronObelisk")) {
        if (CheckActorInventory(playerTID, "XPLevel")+1 < 12) {
            SetActivator(playerTID);
            PrintBold(s:"You must be at least level 12 to activate this obelisk.");
            terminate;
        }
    }

    //Prevent reuse without using ACS_Execute (instead of ACS_ExecuteAlways).
    //We need this so that multiple boss fights can be ongoing at the same time from different obelisks!
    SetActorState(0, "SitDisabledSpecial");
    
    Radius_Quake2(0, 6, 375, 0, 256, "world/quake");
    //PlaySound(0, "obelisk1", CHAN_BODY, 1.0, 0, ATTN_NORM);
    SpawnForced("ObeliskBeam", GetActorX(0), GetActorY(0), GetActorZ(0), 0, 0);
    Delay(375 + 56);
    
    str message = "The stone obelisk has been captured.";
    if (CheckActorClass(0, "SiliconObelisk")) {
        SpawnSpotFacingForced("DoomZBossImp", bossSpawnSpotTID, bossTID);
        message = "The silicon obelisk has been restored.";
    } else if (CheckActorClass(0, "IronObelisk")) {
        SpawnSpotFacingForced("DoomZBossCyberdemon", bossSpawnSpotTID, bossTID);
        message = "The iron obelisk has been restored.";
    } else {
        SpawnSpotFacingForced("DoomZBossCacodemon", bossSpawnSpotTID, bossTID);
    }
    
    //Wait until the boss is dead.
    while (ThingCount(T_NONE, bossTID) > 0) {
        delay(35);
    };
    

    Radius_Quake2(0, 3, 120, 0, 256, "world/quake");

    //Lower the floor in the arg...
    //Log(s:"Boss dead!");
    Floor_LowerToNearest(sectorFloorLowerTag, 8);
    
    //Set the obelisk to the active state
    SetActorState(0, "Active");
        
    SetActivator(playerTID);
    PrintBold(s:message);
}

script 965 (int message)
{
    PrintBold(s:"The ", n:0, s:" is under attack! Protect it!");
    Delay(35*10);
}


//Crow/bird spawner script
//This is based on the berry spawner script. See script 962 for comments!
script 966 OPEN CLIENTSIDE
{
	int questSpotTID = -1;
	
	//Spawn some crows to initialize the world:
	for (int i = 0; i < BASE_CROW_COUNT; i++)
	{
		questSpotTID = getRandomEasyQuestSpotTID();
		SpawnProjectile(questSpotTID, "CrowSpawnerProjectile", random(0, 255), 50, 0, 1, 0);
	}
	
	//int BERRY_PLAYER_SCALING = 5; //This works pretty well and gives nice integer numbers in the calculation below.
	//int MAX_BERRY_PLANTS_SCALED = ((PlayerCount()-1)*BASE_BERRY_PLANTS)/BERRY_PLAYER_SCALING + BASE_BERRY_PLANTS;
    int MAX_CROWS_SCALED = BASE_CROW_COUNT;

	while(true) {
		Delay(BIRD_SPAWNER_INTERVAL_SECONDS*35);
		
		//print(d:ThingCount(T_NONE, BERRY_PLANT_TID));
		while (ThingCount(T_NONE, WILD_BIRD_TID) > MAX_CROWS_SCALED) {
			SetActorState(WILD_BIRD_TID, "MaybeDie");
			Delay(2);
		};
		
		//Spawn a bunch of crows to get us back up to the max amount.
		int numCrowsNow = ThingCount(T_NONE, WILD_BIRD_TID);
		for (i = 0; i < MAX_CROWS_SCALED - numCrowsNow; i++) {
			questSpotTID = getRandomEasyQuestSpotTID();
			SpawnProjectile(questSpotTID, "CrowSpawnerProjectile", random(0, 255), 50, 0, 1, 0);
		}
	};
}

//Set the activator TID to WILD_BIRD_TID
script 967 (void)
{
    Thing_ChangeTID(0, WILD_BIRD_TID);
}


//Jack script
script 968 (int direction) //Default (0) is up, 1 is down
{
    if (direction == 0) 
    {
        //SetActorProperty(0, APROP_Height, GetActorProperty(0, APROP_Height) + 4.0);
        SetActorVelocity(0, 0.0, 0.0, 2.0, false, false);
        Delay(4);
        SetActorVelocity(0, 0.0, 0.0, 0.0, false, false);
    }
    else {
        SetActorVelocity(0, 0.0, 0.0, -2.0, false, false);
        Delay(4);
        SetActorVelocity(0, 0.0, 0.0, 0.0, false, false);
    }
}

// Jack top/base script for when they're hit with the axe or activated.
script 969 (void)
{

    SetActivatorToTarget(0);
    
    if (CheckActorClass(0, "JackBase")) {
        SetActorState(0, "Pain.GoDown");
    } else if (CheckActorClass(0, "JackTop")) {
        SetActorState(0, "Pain.Down");
    } else {
        //Log(s:"JackBase nor JackTop are not activator, bailing");
        terminate;
    }
}

//Parachute deployment script
script 970 (int delayTics)
{
    if (delayTics > 0) {
        Delay(delayTics);
    }
    
    int origGravity = GetActorProperty(0, APROP_GRAVITY);
    if (origGravity == 0.0) {
        //Already parachuting, so abort!
        terminate;
    }
    SetActorProperty(0, APROP_GRAVITY, 0.0);
    
    int exitConditionCounter = 0;
        
    int parachuteTID = PARACHUTE_TID_MIN + PlayerNumber();
    Thing_Remove(parachuteTID); //Remove any old parachutes for this player.
    
    int paraX = GetActorX(0);
    int paraY = GetActorY(0);
    int paraZ = GetActorZ(0) + GetActorViewHeight(0);
    int paraAngle = GetActorAngle(0);
    
    SpawnForced("Parachute", paraX, paraY, paraZ, parachuteTID, paraAngle);
    //PlaySound(0, "parachute/pull", CHAN_AUTO, 1.0);
    Delay(3);
    //PlaySound(parachuteTID, "parachute/unfurl", CHAN_AUTO, 1.0);

    while (true)
    {    
        int z = GetActorZ(0) - GetActorFloorZ(0);

        int velZ = GetActorVelZ(0);

        if (velZ < -4.0) {
            ThrustThingZ(0, 10, 0, 1);
        }
        
        if (z <= 0 || velZ >= 0) {
            exitConditionCounter++;
            
            //Allow some leeway so if you activate the parachute at the height of your jump, you'll still be OK.
            if (exitConditionCounter >= 1) { // 1 = no leeway
                SetActorProperty(0, APROP_GRAVITY, origGravity);
                //Thing_Destroy(parachuteTID, 0, 0);
                SetActorState(parachuteTID, "Death");
                //PlaySound(parachuteTID, "parachute/flop", CHAN_AUTO, 1.0);
                terminate;
            }
        }
        
        paraX = GetActorX(0);
        paraY = GetActorY(0);
        paraZ = GetActorZ(0) + GetActorViewHeight(0);
        paraAngle = GetActorAngle(0);
        SetActorPosition(parachuteTID, paraX, paraY, paraZ, false);
        SetActorAngle(parachuteTID, paraAngle);
        SetActorVelocity(parachuteTID, GetActorVelX(0), GetActorVelY(0), GetActorVelZ(0), false, false);

        Delay(5);
    }
}

//Parachute auto-deploy script (called from the player)
script 971 (void)
{
    int fallingCounter = 0;

    while (true)
    {
        Delay(8);
        if (GetActorVelZ(0) <= -8.0) {
            fallingCounter++;
        } else {
            fallingCounter = 0;
        }
        
        int heightDifference = GetActorZ(0) - GetActorFloorZ(0);
        
        if (fallingCounter >= 2 && heightDifference > 400.0) {
            UseActorInventory(0, "ParachuteItem");
            Delay(3*35); //Don't let it happen again for 3 seconds.
            fallingCounter = 0;
        }
    }


    /*
    int tempTID = UniqueTID(SAFE_UNIQUE_TID_MIN, SAFE_UNIQUE_TID_MAX-SAFE_UNIQUE_TID_MIN);
    Thing_ChangeTID(0, tempTID);

    //FIXME: Give ourselves a TID so we can set the parachute as the activator again below?
    SetActivator(tempTID, AAPTR_MASTER);
    int x = GetActorX(0);
    int y = GetActorY(0);
    int z = GetActorZ(0);
    
    Log(f:x, s:" ", f:y, s:" ", f:z);
    
    SetActivator(tempTID);
    SetActorPosition(tempTID, x, y, z, 0);
    
    //Remove the TID
    Thing_ChangeTID(tempTID, 0);
    */
}


//Hoist script
script 972 (int direction) //Default (0) is up, 1 is down
{
    
    if (direction == 0) 
    {
        //SetActorProperty(0, APROP_Height, GetActorProperty(0, APROP_Height) + 4.0);
        SetActorVelocity(0, 0.0, 0.0, 2.0, false, false);
        //Delay(4);
        //SetActorVelocity(0, 0.0, 0.0, 0.0, false, false);
    }
    else {
        SetActorVelocity(0, 0.0, 0.0, -2.0, false, false);
        //Delay(4);
        //SetActorVelocity(0, 0.0, 0.0, 0.0, false, false);
    }
}

// Hoist base script, when it's hit with an axe
script 973 (void)
{

    SetActivatorToTarget(0);
    
    if (CheckActorClass(0, "HoistBase")) {
        SetActorState(0, "Pain.GoDown");
    } else if (CheckActorClass(0, "HoistLift")) {
        SetActorState(0, "Pain.Lift");
    } else {
        terminate;
    }
}

// Client-side vegetation toggle (dz_toggleveggies)
script 974 (void) NET CLIENTSIDE
{
    g_vegetationEnabled = !g_vegetationEnabled;
    if (g_vegetationEnabled) {
        Print(s:"Procedural vegetation enabled");
    } else {
        Print(s:"Procedural vegetation disabled");
    }
}

//Nobody reads, so force people to turn on OpenGL, and force models to be on.
script 975 ENTER CLIENTSIDE
{
	if (!GetCVar("vid_renderer")) {
        SetFont("HELP");
        SetHudSize(1,1,0);
        HudMessage(s:"A"; HUDMSG_PLAIN, 964, 0, 0, 0, 0);
        
        SetHudSize(0,0,0);

        SetFont("BIGFONT");
        HudMessage(s:"You must turn on OpenGL to play!"; 
                    HUDMSG_PLAIN, 955, CR_GOLD, 0.5, 0.5, 0.0);
        HudMessage(s:"Press Escape, and go to Options->Set Video Mode\nand set Renderer to OpenGL"; 
                    HUDMSG_PLAIN, 956, CR_RED, 0.5, 0.6, 0.0);
        SetFont("SMALLFONT");
    }
    
    //Force models to be on.
    ConsoleCommand("gl_use_models 1");
}


//Check if a boat is on or under water.
//The boat is assumed to be the activator.
script 978 (void)
{
    //This works in Zandronum 3.0 but APROP_Waterlevel is 
    //not implemented in Zandronum 2.0. :-(
    //In Zandro 2, we cheat by including stone pebbles in the floor
    //check here, because the other texture checks don't work
    //underwater in Zandro 2. (didn't test that explicitly in 3.0 though.)
    
    //SetResultValue(true);
    //terminate;
    if (CheckActorFloorTexture(0, "FWATER1") 
        || CheckActorFloorTexture(0, "WFALL1") 
        || CheckActorFloorTexture(0, "MFLR8_3") //Marble pebbles 
        || CheckActorCeilingTexture(0, "FWATER1") 
        || CheckActorCeilingTexture(0, "WFALL1") 
        || GetActorProperty(0, APROP_Waterlevel) > 0) {
        SetResultValue(true);
    }
    else {
        SetResultValue(false);
    }
}



script 1000 (int exitingWorldNum, int enteringWorldNum) 
{
    //TODO: Give the player an inventory item that tells the next map
    //      where they should spawn.
    int playerIdx = PlayerNumber();
    if (playerIdx >= 0) {
    
    	if (!PlayerIsLoggedIn(playerIdx))
        {
            Print(s:"You must be logged into travel to this way.");
            ActivatorSound("menu/invalid", 127);
            terminate;
        }
        
        //Save their inventory and connect them to the next server.
        if (ACS_ExecuteAlways(810, 0, playerIdx)) {
            //Make the player connect to the other server.
            Delay(15);
            Print(s:"Travelling...");
            TakeInventory("TravelDestination", 0x7FFFFFFF);
            GiveInventory("TravelDestination", 2);
            Delay(35);
            ACS_ExecuteAlways(1001, 0, 0); //Called on the client side!
        }
    }
}

script 1001 (void) CLIENTSIDE
{
    FadeTo(0, 0, 0, 1.0, 0.5); //Fade to black
    ConsoleCommand("cl_startasspectator false");
    ConsoleCommand("connect localhost:10667");
    ConsoleCommand("cl_startasspectator true");
}