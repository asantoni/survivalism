#include "zcommon.acs"
#import "math.acs"
#import "music.acs"
#import "doomzgame.acs"
#import "quests.acs"
#import "messages.acs"
#library "player" //Must be last!


#libdefine PLAYER_MIN_TID 1010
#define PLAYER_SPEED 0.3

#libdefine MAX_PLAYERS 64

#define HUNGER_START_LEVEL 14 	  //XP level where the hunger system kicks in.

#define HUNGER_GOOD_LEVEL 55 		//Less than this, you're "Well Nourished"
#define HUNGER_PECKISH_LEVEL 65 	//"Getting hungry"
#define HUNGER_STARVING_LEVEL 80 	//The level at which you start to "starve"
#define MAX_HUNGER_LEVEL 100		//MaxAmount for the HungerLevel inventory item 


int g_secondsSincePlayerJoined[MAX_PLAYERS];

#define DROPPABLE_INVENTORY_START 9 //DeathCurse
#define PERSISTENT_INVENTORY_LEN 82
//XXX: You must update DECORATE.PLAYER too! It also has PERSISTENT_INVENTORY_LEN.

int persistentInventory[PERSISTENT_INVENTORY_LEN] =
{
	//YOU MUST UPDATE PERSISTENT_INVENTORY_TABLE_LENGTH WHEN YOU ADD
	//NEW ITEMS TO THIS ARRAY!
//XP and level used to be handled as a special case, but with per-tic auto-save, it's safe to have them here:
    "XP",
    "XPLevel",
	"InventoryGuardItem",
	"HungerLevel", //Hunger is saved with your inventory. Helps dissuade cheating.
    "HealthBooster1",
    "HealthBooster2",
    "HealthBooster3",
    "TravelDestMap",
    "TravelDestPathway",
//DROPPABLE_INVENTORY_START offset starts here!
//Put only items that are dropped into the backpack on death below this line:
	"DeathCurse", //Being cursed by death is saved too.
	"Knife",
	"Yellowboy",
	"DoomZChainsaw",
	"DoomZShotgun",
	"DoomZSuperShotgun",
	"DoomZPistol",
	"Glock18",
	"DoomZChaingun",
	"HuntingRifle",
	"WensternShotgun",
    "WesternShotgun",
    "HeavyRifle",
	"Bucket",
	"Bow",
	"GraplingAmmo",//Rope
	"GasolineAmmo",
	"WaterAmmo",
	"PistolClip",
	"ChaingunClip",
	"HuntingRifleClip",
    "HeavyRifleClip",
    "9mmPistolBullet",
    "GlockBullet",
    "ChaingunBullet",
    "HuntingRifleBullet",
    "HeavyRifleAmmo",
    "LoadedShotgunShell",
    "LoadedYellowboyShell",
	"LootBox",
	"CBoxItem",
	"CKitItem",
	"CDoorItem",
	"CFloorItem",
	"CPillarItem",
	"CStoneBoxItem",
	"CraftingBoxItem",
	"QuestBoxItem",
	"FurnaceItem",
	"Coal",
	"Steel",
	"SentryBox",
	"AdvancedSentryBox",
	"TorchItem",
	"TurnipSeeds",
	"Turnip",
	"TreeSeeds",
	"HempSeeds",
	"FireSpell",
	"DoomZEgg",
	"ChickenItem",
	"CookedChicken",
    "LogItem",
	"GargoyleStatueItem",
	"TechLampItem",
	"FloorLampItem",
	"SpikeItem",
	"BlueberryItem",
	"StrawberryItem",
	"CranberryItem",
	"BerryMash",
    "IronOre",
    "CSteelBoxItem",
    "Silica",
    "ComputerChip",
    "JackItem",
    "HoistItem",
    "CGlassBoxItem",
    "ParachuteItem",
	"ArrowAmmo",
	"Cotton",
    "BoatItem",
    "AmmoBelt",
};

#define NUM_XP_LEVELS 59 
int xpLevelTable[NUM_XP_LEVELS] = {
0,500,1700,3600,6200,9500,13500,18200,29700,36500, //Levels 1-11
44300, 53100, 62900, 73700,85500,98300,112100,126900,142700, //Levels 12-20
159500, //Level 21
177300,
196100,
215900,
236700,
258500,
281300,
305100,
329900,
355700, //Level 30
382700,
410900,
440300,
470900,
502700,
535700,
569900,
605300,
641900,
679700, //Level 40
718700,
758900,
800300,
842900,
886700,
931700,
977900,
1025300,
1073900,
1123700, //Level 50
1175000,
1227800,
1282100,
1337900,
1395200,
1454000,
1514300,
1576100,
1639400,
1704200  //Level 60
};

//bool isPlayerPseudoSpectator[MAX_PLAYERS];

/* REMEMBER: You can't have scripts numbered over 1000! */

int playerHasLoadedInventory[MAX_PLAYERS] = {
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
};

//Inventory saving/loading in-memory cache (for speed - saving to DB is slow):
str g_accountNameForPlayer[MAX_PLAYERS][127];                         //Need to keep track of the account names for all players
int g_inventoryCountForPlayer[MAX_PLAYERS][PERSISTENT_INVENTORY_LEN]; //Need to keep track of all inventory items for all logged in players.


script 99 OPEN
{
    /*
	for (int i = 0; i < MAX_PLAYERS; i++)
	{
		isPlayerPseudoSpectator[i] = false;
	}*/
    for (int playerIdx = 0; playerIdx < MAX_PLAYERS; playerIdx++)
    {
        g_secondsSincePlayerJoined[playerIdx] = 0;
    }
}

//Called when the player enters
script 100 ENTER
{
	//isPlayerPseudoSpectator[PlayerNumber()] = false; //Reset this flag    

	Thing_ChangeTID(0, PLAYER_MIN_TID+PlayerNumber());
	int playerTid = PLAYER_MIN_TID+PlayerNumber();

    Delay(5); //Give the server 5 tics to load the player's inventory before we enter setupPlayer().
              //We need this (for example) to avoid giving them the parachute when travelling between worlds.

	setupPlayer(playerTid);
    
    g_secondsSincePlayerJoined[PlayerNumber()] = 0;
	
	//restorePersistentInventory(PlayerNumber());
	
	//Draw HUD
	ACS_ExecuteAlways(102, 0, 0);
	
	//Hunger loop
	ACS_ExecuteAlways(851, 0, playerTid);
    
    //Parachute auto-deploy
    ACS_ExecuteAlways(971, 0, 0);

    //Fade-in from black if the player is travelling
//    Delay(15);
//    FadeTo(0, 0, 0, 0.0, 1.0);
}

//Clientside variables
int clientQuestTimeLeft = -1;
int clientCompassTID = 0; //TID to point towards

//function void showLifeTimerOnHUD(void)
script 102 (void) CLIENTSIDE  
{
	int t;
	int playerSpawnTime = Timer();
	//while(PlayerHealth() > 0)
	while (true)
	{
		t = (Timer() - playerSpawnTime) / 35;
		SetFont("SMALLFONT");
		HudMessage(s:"You've been alive for: ", d:t/60, s:":", d:(t%60)/10, d:t%10;
			HUDMSG_PLAIN, HUDMSG_ALIVE_TIMER, CR_RED, 0.90, 0.90, 2.0);

		//From quests.acs:

		if (clientQuestTimeLeft > -1)
		{
			int qt = clientQuestTimeLeft; //g_activeQuestStats[questIdx][QUEST_STATS_TIMELEFT];
			HudMessage(s:"Quest Time Left: ", d:qt/60, s:":", d:(qt%60)/10, d:qt%10;
					HUDMSG_PLAIN, HUDMSG_ALIVE_TIMER, CR_GOLD, 0.90, 0.92, 2.0);
					
			//Draw the quest compass.
			if (clientCompassTID != 0) {
				//Print(s:"Compass pointing at:", d:clientCompassTID);
				int tidToPointAt = clientCompassTID;
				int dirX = GetActorX(tidToPointAt) - GetActorX(0);
				int dirY = GetActorY(tidToPointAt) - GetActorY(0);
				int vangle = VectorAngle(dirX, dirY);
				int angle = (vangle - GetActorAngle (0) + 1.0) % 1.0;

				if (angle < 0.2 || angle > 0.8)
				{
					int sx = 320 - (320 * Sin (angle) / Cos (angle));

					SetFont("BIGFONT");
					SetHudSize (640, 480, 0);
					HudMessage (s:"^"; HUDMSG_PLAIN, HUDMSG_ID_COMPASS, CR_RED, sx * 1.0, 25.2, 0);
				}
				else
				{
					HudMessage (s:""; HUDMSG_PLAIN, HUDMSG_ID_COMPASS, 0, 0, 0, 0);
				}
				SetHudSize(0, 0, false);
			} else { //COMPASSDIR == 0
				HudMessage (s:""; HUDMSG_PLAIN, HUDMSG_ID_COMPASS, 0, 0, 0, 0);
			}
		} else {
			HudMessage (s:""; HUDMSG_PLAIN, HUDMSG_ID_COMPASS, 0, 0, 0, 0);
			HudMessage (s:""; HUDMSG_PLAIN, HUDMSG_ALIVE_TIMER, 0, 0, 0, 0);
		}
		
		SetFont("SMALLFONT");
		
		//Draw the XP meter
		int progressCentigrade = CheckInventory("XPProgress");
		int progressDecigrade = progressCentigrade / 10;
		
		/* These logging statements show the 32-bit serverside / 16-bit clientside signed overflow bug:
		Log(s:"Progress centigrade:", d:progressCentigrade);
		Log(s:"Progress:", f:fProgress);
		Log(s:"Current XP:", d:CheckInventory("XP"));
		*/
		
		int hudWidth = 320;
		SetHudSize(hudWidth, 240, false);
        HudMessage(s:"[==========]"; HUDMSG_PLAIN, HUDMSG_ID_XPMETER, CR_GREY, 320.2, 2.1, 0);
        int pixelsPerCharacter = 5;
        HudMessage(s:">"; HUDMSG_PLAIN, HUDMSG_ID_XPMETERTICK, CR_GREEN, 320.2-(pixelsPerCharacter*10.0)+((progressDecigrade*pixelsPerCharacter)<<16), 2.1, 0);
	
        HudMessage(s:"Level: ", d:CheckInventory("XPLevel")+1; HUDMSG_PLAIN, HUDMSG_XP_LEVEL, CR_GREEN, 320.2, 10.1, 0);

		int hungerLevel = CheckInventory("HungerLevel");
		int hungerText = "Well Nourished";
		int hungerColour = CR_GREEN;
		
		if (hungerLevel <= HUNGER_GOOD_LEVEL) {
			hungerText = "Well Nourished";
		} else if (hungerLevel <= HUNGER_PECKISH_LEVEL) {
			hungerText = "Getting Hungry";
			hungerColour = CR_YELLOW;
		} else if (hungerLevel >= HUNGER_STARVING_LEVEL) {
			hungerText = "Starving";
			hungerColour = CR_RED;
		} else {
			hungerText = "Hungry";
			hungerColour = CR_ORANGE;
		}
		
        if (CheckInventory("XPLevel") > HUNGER_START_LEVEL-1) {
            HudMessage(s:hungerText; HUDMSG_PLAIN, HUDMSG_ID_HUNGER, hungerColour, 320.2, 18.1, 0);
        }

        
        if (DEBUG_MODE==1) {
            HudMessage(s:"DEBUG MODE";
                HUDMSG_PLAIN, HUDMSG_ID_DEBUGMODE, CR_ORANGE, 312.2, 26.1, 2.0);    
            HudMessage(d:CheckInventory("MonsterSpawnerCharge");
                HUDMSG_PLAIN, HUDMSG_ID_MSCHARGE, CR_GREEN, 312.2, 34.1, 2.0);   
        }
		
		SetHudSize(0, 0, false);
		Delay(3);
	}
}

//Pass quest HUD variables from the server to the client.
script 103 (int playerNum, int questTimeLeft, int compassTID) CLIENTSIDE
{
	//Print(s:"Client says player received from server is:", d:playerNum);
	//Print(s:"Client says we are:", d:ConsolePlayerNumber());
	if (ConsolePlayerNumber() == playerNum) //No way to ONLY send to specific clients unfortunately
	{
		clientQuestTimeLeft = questTimeLeft;
		clientCompassTID = compassTID;
	}
}

//104 is reserved for Axe.wad
//script 104

//Melee action
script 105 (void) NET
{
    if (CheckInventory("XPLevel") >= 20) { //Level 21
        GiveInventory("AxeMeleeAction", 1);
    } else {
        GiveInventory("FistMeleeAction", 1);    
    }
}

//Melee puff thrust
//Needs its own script because kickback is determined by damage and the weapon's primary
//fire kickback. There's no kickback for A_CustomPunch...
script 106 (void)
{
    SetActivator(0,AAPTR_TARGET); //Get the puff's target, which is the player due to +PUFFGETSOWNER
    int playerAngle = GetActorAngle(0);
    int playerTID = ActivatorTID();
    
    //Push the actor the player was looking at
    if (SetActivator(0, AAPTR_PLAYER_GETTARGET)) {
    
        int flags = ClassifyActor(0);
        if (((flags & ACTOR_MONSTER) && (flags & ACTOR_ALIVE)) || (flags & ACTOR_PLAYER))
        {
            //TODO: Use CheckFlags in Zandronum 3.0 to check if the target has
            //      +WINDTHRUST. Everything that can be WINDTHRUST should be punchable.
            //      As a workaround, we're just going to check if the TID is a monster TID.
            int targetTID = ActivatorTID();
            if (targetTID >= BADDIES_TID_MIN && targetTID <= BADDIES_TID_MAX) {
                if (fdistance(0, playerTID) < 128.0) { 
                    ThrustThing((playerAngle >> 8), 16, 0, 0);
                }      
            }
        }
    }
}



script 807 DEATH
{
	//Thing_ChangeTID(0, 0); //Try removing the TID of the player's corpse.
	//isPlayerPseudoSpectator[PlayerNumber()] = true;
	
	//Wipe the player's inventory from the database
	ACS_ExecuteAlways(811, 0, 0);


    SetFont("SMALLFONT2");
    SetHudSize(640,480,1);
    HudMessage(s:"\n\nYour inventory has been dropped in a backpack.\nRecover it!";
                HUDMSG_PLAIN, INFO_MESSAGE_ID, CR_GOLD, 320.4, 250.1, 6.0);
}


//Called when the player respawns
script 808 RESPAWN
{
    Delay(1);
	//Log(s:"RESPAWN called");
	// Make sure our old dead body doesn't still have our tid
	Thing_ChangeTID(PLAYER_MIN_TID+PlayerNumber(),0);
	Thing_ChangeTID(0,PLAYER_MIN_TID+PlayerNumber());

	int playerTid = PLAYER_MIN_TID+PlayerNumber();
	
	SetActorProperty(playerTid, APROP_Invulnerable, 0);
	Delay(1);
	TakeActorInventory(playerTid, "MonsterSpawnerMode", 99999); // Just in case. Bugfix for craziness in multiplayer?
	Delay(1);


	//READ: http://zdoom.org/wiki/About_Multiplayer,_Scripts,_and_TIDs
	//All previously running scripts are inherited by the respawned player automatically!
	
	//Log(s:"done respawn, setting up player...");
	setupPlayer(playerTid);
	
	//Start the alive time timer
	//ACS_ExecuteAlways(102, 0, 0);
}

function void giveInitialInventory (int playerTid)
{
	GiveActorInventory(playerTid, "DoomZBoxPlacer", 1);
	GiveActorInventory(playerTid, "Axe", 1);
    GiveActorInventory(playerTid, "SpawnParachuteItem", 1);

	//GiveActorInventory(playerTid, "Fist", 1);
	if (CheckActorInventory(playerTid, "XPLevel") > 14) {
        Log(s:"Player XP level is: ", d:CheckActorInventory(playerTid, "XPLevel"));
		GiveActorInventory(playerTid, "InventoryGuardItem", 1);
	}
}

function void setupPlayer(int playerTid)
{
	TakeActorInventory(playerTid, "PseudoSpectatorFlag", 0x7FFFFFFF);
	SetActorProperty(playerTid, APROP_Invulnerable, 0);
	SetActorProperty(playerTid, APROP_RenderStyle, STYLE_Normal);
	SetActorProperty(playerTid, APROP_Alpha, 1.0);

    if (CheckActorInventory(playerTid, "TravelDestPathway") <= 0) //Only if the player isn't travelling between worlds/maps.
    {
        giveInitialInventory(playerTid);

        //Move the actor to the ceiling because UsePlayerStartZ in MAPINFO isn't working in Zandronum 2.0 (Try without this in Zandronum 3.0?)
        SetActorPosition(playerTid, GetActorX(playerTid), GetActorY(playerTid), GetActorCeilingZ(playerTid) - 128.0, false);

        //Make the player parachute in, if they're not spawning on ground.
        UseActorInventory(playerTid, "SpawnParachuteItem");
    }
    
	//Summon Death to stalk the player if they're cursed by it.
	if (CheckActorInventory(playerTid, "DeathCurse") > 0) {
		ACS_ExecuteAlways(955, 0, 0);
	}
    
    if (CheckActorInventory(playerTid, "XPLevel") >= 15) {
		SetActorProperty(playerTid, APROP_SpawnHealth, 120);
        GiveActorInventory(playerTid, "Health", 20);
	}
    
    //Log(s:"Dude got dis many: ", d:CheckActorInventory(playerTid, "HealthBooster1"));
    if (CheckActorInventory(playerTid, "HealthBooster1") > 0) {
        ACS_ExecuteAlways(900, 0, playerTid); //See ARTIFACTS.acs
	}
}


function void setupPseudoSpectator (int playerTid)
{
/*
    SetFont("BIGFONT");
	HudMessage(s:"You have died.\nYou will respawn in 15 seconds.";
			HUDMSG_PLAIN, 2, CR_RED, 0.5, 0.7, 5.0);
*/
	GiveActorInventory(playerTid, "PseudoSpectatorFlag", 1);
	GiveInventory("PseudoSpectatorMorph", 1);
	//MorphActor(playerTid, "PseudoSpectator", "", 1048576, 0, "", "");

	/*
    int PLANCAM_TID = 500;
	Spawn("PseudoSpectator", 
		  GetActorX(0), GetActorY(0), 100*65536,//GetActorCeilingZ(0) - 4,
		  PLANCAM_TID);
	int tidToFollow = 1000 + PlayerNumber();
	SetThingSpecial(PLANCAM_TID, 0, 45, 0, 0, tidToFollow);
	*/
	//SetActorProperty(ActivatorTID(), APROP_Gravity, 0.0);
	//int morphed = MorphActor(playerTid, "Imp", 0, 1048576, 0);
	//MorphActor(playerTid, "PseudoSpectator", "", 1048576, 0, "", "");
}

//Turn a pseudospectator back into a player and teleport them to a spawn point.
/*
script 809 (void)
{
	Spawn("TeleportFog", GetActorX(0), GetActorY(0), GetActorZ(0));
}*/

function bool restorePersistentInventory (int playerIdx)
{
	if (!PlayerIsLoggedIn(playerIdx))
	{
		Print(s:"If you were logged in, we would be restoring your inventory!");
		return false;
	}
	if (playerHasLoadedInventory[playerIdx] > 0) {
		HudMessage(s:"You can only load your inventory once each time you save it."; 0, 0, CR_RED, 0.5, 0.5, 3.0);
		return false;
	}
	str accountName = GetPlayerAccountName(playerIdx);
	str namespace = strparam(s:accountName, s:"_inventory");

    //Print(s:"Restoring your inventory...");
    int playerTid = PLAYER_MIN_TID + playerIdx;
    
    //Clears all UNDROPPABLE inventory first - Prevents changemap Heretic behaviour from adding 1 to all your items,
    //and also prevents your XP from stacking.
    ClearActorInventory(playerTid); 
    
    for (int i = 0; i < PERSISTENT_INVENTORY_LEN; i++) {
        GiveActorInventory(playerTid, persistentInventory[i], GetDBEntry(namespace, persistentInventory[i]));
    }
    
    giveInitialInventory(playerTid);
	
	//XP and level are handled as a special case:
    //GiveActorInventory(playerTid, "XP", GetDBEntry(namespace, "XP"));
    //GiveActorInventory(playerTid, "XPLevel", GetDBEntry(namespace, "XPLevel"));
    
	//GiveActorInventory(playerTid, "PlayerHasLoadedInventory", 1);
	playerHasLoadedInventory[playerIdx] = 1;
    
    //Trigger recalculation progressCentigrade to workaround netcode problem.
    //If we don't do this, your XP bar won't show the correct value until you get more XP.
    recalculateCentigradeWorkaround(playerIdx);
    //ACS_ExecuteAlways(817, 0, 1);
	

    bool bShowHUDMessage = true;

    //Don't show the message when restoring inventory after travelling, to make the experience a little more seamless.
    if (CheckActorInventory(playerTid, "TravelDestPathway") > 0)
    {
        bShowHUDMessage = false;
    }

    if (bShowHUDMessage)
    {
        HudMessage(s:"Inventory restored!\nWelcome back, ", n:0, s:"."; 0, 0, CR_GOLD, 0.5, 0.5, 3.0);
    }
	return true;
}

function bool validateSaveAction(int playerIdx)
{
    /* This code is called from a DISCONNECT some times (via script 810) so we can't
       use the account functions like this:
	if (!PlayerIsLoggedIn(playerIdx)) {
        return false;
    }
    */

    //Grab cached account name for player
    str accountName = StrParam(a:g_accountNameForPlayer[playerIdx]);
    if (strcmp(accountName, "") == 0) {
        Log(s:"The player wasn't logged in, aborting save.");
        return false; //Player is not logged in!
    }

    //Don't allow the player to save if they already have a saved character with a higher XP level.
	str namespace = strparam(s:accountName, s:"_inventory");
    int xpLevel = g_inventoryCountForPlayer[playerIdx][0]; 
    if (strcmp(persistentInventory[1], "XPLevel") != 0) {
        Log(s:"Assertion Failed:");
        Log(s:"BIG FAT ERROR: XPLevels aren't being saved due to XPLevel not being index 1 in the array. ASSERTION FAILED!");
        return false;
    }
    if (GetDBEntry(namespace, "XPLevel") > xpLevel) {
        //This means something real bad happened - programming error?
        Log(s:"ERROR: This player was already saved with a higher XP level somehow. Aborting save for safety.");
        return false;
    }
    return true;
}

script 810 /*savePersistentInventoryAndXP*/ (int playerIdx, int noHUDMessage)
{
	int playerTid = PLAYER_MIN_TID + playerIdx;

    //XXX: PlayerIsLoggedIn() doesn't work from a DISCONNECT script
    // so we just check if our cached accountName below is empty or not.
    /* Old code:
	if (!PlayerIsLoggedIn(playerIdx))
	{
		Print(s:"You must be logged in save your inventory.");
		ActivatorSound("menu/invalid", 127);
		SetResultValue(false);
		terminate;
	}*/
    
    //XXX: GetPlayerAccountName doesn't work when called from a DISCONNECT script,
    //     so we cache it as g_accountNameForPlayer when they log in.
	//str accountName = GetPlayerAccountName(playerIdx);

    str accountName = StrParam(a:g_accountNameForPlayer[playerIdx]);
        /*
    if (StrCmp(accountName, "") == 0) {
        Log(s:"Player was not logged in, aborting save.");
        setResultValue(false);
        terminate;
    }*/
    
    if (!validateSaveAction(playerIdx))
    {
        Log(s:"Save for player aborted.");
    	//print(s:"You should load your inventory before you save over it.");
        ActivatorSound("menu/invalid", 127);
		SetResultValue(false);
		terminate;
    }
    
    Log(s:"savePersistentInventoryAndXP: Saving inventory with namespace: ", s:accountName, s:" from ", a:g_accountNameForPlayer[playerIdx]);
	str namespace = strparam(s:accountName, s:"_inventory");
	
    //Print(s:"Saving your inventory...");
	Log(s:"Saving inventory for player ", d:playerIdx, s:": ", s:accountName);
	BeginDBTransaction();
    for (int i = 0; i < PERSISTENT_INVENTORY_LEN; i++) {
        //SetDBEntry(namespace, persistentInventory[i], CheckActorInventory(playerTid, persistentInventory[i]));
        SetDBEntry(namespace, persistentInventory[i], g_inventoryCountForPlayer[playerIdx][i]);
  
		//print(s:persistentInventory[i], s:" amount:", d:CheckActorInventory(playerTid, persistentInventory[i]));
    }
    
	//XP and level are handled as a special case:
	//SetDBEntry(namespace, "XP", CheckActorInventory(playerTid, "XP"));
	//SetDBEntry(namespace, "XPLevel", CheckActorInventory(playerTid, "XPLevel"));

	EndDBTransaction();
    //print(s:"Inventory saved!");
    if (noHUDMessage == 0)
    {
        HudMessage(s:"Inventory saved!"; 0, 0, CR_GOLD, 0.5, 0.5, 3.0);
    }

    //ActivatorSound("misc/spawn", 127);
	//playerHasLoadedInventory[playerIdx] = 1; //Don't allow you to save and then load!
    
    g_accountNameForPlayer[playerIdx][0] = '\0';
    
	setResultValue(true);
	//KickFromGame(playerIdx, "Saved and quit!");
}


//Called on death!
script 811 /* wipePersistentInventory*/ (void)
{
	int playerTid = PLAYER_MIN_TID + PlayerNumber();
	
	if (!PlayerIsLoggedIn(PlayerNumber()))
	{
		terminate;
	}
    
    int playerIdx = PlayerNumber();
    for (int i = 0; i < PERSISTENT_INVENTORY_LEN; i++) {
        g_inventoryCountForPlayer[playerIdx][i] = 0;
    }
    
    /* Don't need to wipe this in the DB - just wipe it in our in-memory cache.
	str accountName = GetPlayerAccountName(PlayerNumber());
	str namespace = strparam(s:accountName, s:"_inventory");
	
	BeginDBTransaction();
    for (int i = 0; i < PERSISTENT_INVENTORY_LEN; i++) {
        SetDBEntry(namespace, persistentInventory[i], 0);
    }
	EndDBTransaction();
    */
	//print(s:"Inventory wiped!");
}

//Loading inventory:
//See script 814 below



/* This function "charges" the monster spawner, which is a potential indicating
   how many monsters (and maybe how nasty) the monster spawner should spawn.
   We use this to add more of a dynamic spatial element to the gameplay. 
   When you're camping during the day, we spawn less monsters to force the player to 
   go explore if they want loot.
   
   All this rolling average and vector derivative stuff
   is just to accomplish that. We use it to give each player a "charge" that
   accumulates as they wander around. The further they go, the higher the charge 
   goes, but it decreases when they stay in one place. We spawn monsters based
   on the charge (as it hits different thresholds), so they player gets action
   when they go exploring, but are otherwise not bothered by too many badguys
   when they're building their base (and consequently can't get loot either.)
*/
script 812 /* chargeMonsterSpawner*/ ENTER
{
	int t;
	//int charge = 0;
	
	//Reset your monster spawner charge when you die
	TakeActorInventory(0, "MonsterSpawnerCharge", 0x7FFFFFFF);
		
	//Only globals can be arrays...
	int oldPlayerX = GetActorX(0);
	int oldPlayerY = GetActorY(0);
	int oldPlayerZ = GetActorZ(0);
	int oldAvgPlayerX = GetActorX(0);
	int oldAvgPlayerY = GetActorY(0);
	int oldAvgPlayerZ = GetActorZ(0);
	
	//int oldPlayerX[3] = {0,0,0};
	/*
	int oldPlayerY[3] = {0,0,0};
	int oldPlayerZ[3] = {0,0,0};
	*/
	int playerSpawnTime = Timer();
	int timestepTics = 70.0;//140.0;//35*4;
	int damping = FixedDiv(timestepTics, 800.0 + timestepTics);
	
	while(PlayerHealth() > 0)
	{
		t = (Timer() - playerSpawnTime) / 35;
				
		int newPlayerX = GetActorX(0);
		int newPlayerY = GetActorY(0);
		int newPlayerZ = GetActorZ(0);	
		
		//Use a low-pass filter as a ghetto rolling average.
		int avgPlayerX = oldAvgPlayerX + FixedMul(damping, newPlayerX - oldAvgPlayerX);
		int avgPlayerY = oldAvgPlayerY + FixedMul(damping, newPlayerY - oldAvgPlayerY);
		int avgPlayerZ = oldAvgPlayerZ + FixedMul(damping, newPlayerZ - oldAvgPlayerZ);
		
		oldPlayerX = newPlayerX;
		oldPlayerY = newPlayerY;
		oldPlayerZ = newPlayerZ;
		
		//Calculate the derivative of the average player position.
		int diffAvgPlayerX = FixedDiv(avgPlayerX - oldAvgPlayerX,timestepTics);
		int diffAvgPlayerY = FixedDiv(avgPlayerY - oldAvgPlayerY,timestepTics);
		int diffAvgPlayerZ = FixedDiv(avgPlayerZ - oldAvgPlayerZ,timestepTics);
		
		int diffAvgLen = fveclength(diffAvgPlayerX, diffAvgPlayerY, diffAvgPlayerZ);
		
		//Print how charged the monster spawner is to the screen for debugging:
		//HudMessage(f:(diffAvgLen);
		//	HUDMSG_PLAIN, 2, CR_RED, 0.5, 0.1, 1.0);
		//Delay(35*1);
		
		oldAvgPlayerX = avgPlayerX;
		oldAvgPlayerY = avgPlayerY;
		oldAvgPlayerZ = avgPlayerZ;
		
		int charge = math_min(diffAvgLen>>16, 8);
		
		TakeActorInventory(0, "MonsterSpawnerCharge", 0x7FFFFFFF);
		Delay(1);
		GiveActorInventory(0, "MonsterSpawnerCharge", charge);
		
		Delay(timestepTics>>16);
	}
}

//Call chargeMonsterSpawner when you respawn too.
script 813 RESPAWN
{
	ACS_ExecuteAlways(812, 0, 0);
}

//loadAndWipePersistentInventory - called from basic crafting menu when you load your inventory and XP
script 814 (void)
{
	int playerTID = ActivatorTID();
	int playerOffset = playerTID - PLAYER_MIN_TID;	
	//Don't allow this button to be pressed if you're spectating
	if (PlayerIsSpectator(playerOffset) > 0 || PlayerIsPseudoSpec(playerOffset))
	{
		terminate;
	}
	//If the activator is not a player, just return.
	if (PlayerNumber() < 0) {
		terminate;
	}

	//Load inventory
    if (restorePersistentInventory(PlayerNumber()))
	{
		//Wipe inventory - You will lose all your inventory if you time out or disconnect without saving again.
		//ACS_ExecuteAlways(811, 0);
	}
}

//saveAndTakePersistentInventory()
script 815 (void)
{
	//Saves all your iventory and takes it from your player
	//so you can't exploit spectator mode to duplicate your inventory.
	
	//Save your inventory
	if (!ACS_ExecuteWithResult(810, 0, PlayerNumber())) {
		terminate;
	}
	
	/*
	//Take it all away from the player
	for (int i = 0; i < PERSISTENT_INVENTORY_LEN; i++) {
        TakeActorInventory(0, persistentInventory[i], 0x7FFFFFFF);
    }
	*/
}

//Gets called when a player disconnects or spectates
script 816 (int playerIdx) DISCONNECT
{
    Log(s:"Script 816 DISCONNECT", d:playerIdx);
    /*
	if (PlayerIsSpectator(playerIdx))
	{
		//Log(s:"Player is spectating");
	}*/
	
	playerHasLoadedInventory[playerIdx] = 0;
    
	//Remove death stalker and ankh
	int deathTID = DEATH_TID_MIN + playerIdx;
	Thing_Remove(deathTID);
	int ankhTID = ANKH_TID_MIN + playerIdx;
	Thing_Remove(ANKH_TID_MIN);

    //XXX: 
    //XXX: 
    //XXX: GetPlayerAccountName nor any of the account-related functions
    //     work from a DISCONNECT script!
    //XXX: 
    //XXX: 
    
    Log(s:"Player disconnected: ", a:g_accountNameForPlayer[playerIdx], s:", index was: ", d:playerIdx);
    for (int i = 0; i < PERSISTENT_INVENTORY_LEN; i++) {
        Log(s:persistentInventory[i], s:" ", d:g_inventoryCountForPlayer[playerIdx][i]);
    }
    //Save your inventory
    ACS_ExecuteAlways(810, 0, playerIdx);    
}

script "saveAllPlayersInventoriesAtMapUnload" UNLOADING
{
    Log(s:"UNLOADING script running!");
    for (int playerIdx = 0; playerIdx < MAX_PLAYERS; playerIdx++) {
        //Save your inventory
        //if (PlayerInGame(playerIdx)) {
            ACS_ExecuteAlways(810, 0, playerIdx);    
        //}
    }
}

function void recalculateCentigradeWorkaround (int playerIdx)
{
    int playerTid = PLAYER_MIN_TID + playerIdx;
    
	int currentPlayerXPLevel = CheckActorInventory(playerTid, "XPLevel");
	int totalXPUntilNextLevel = xpLevelTable[currentPlayerXPLevel+1] - xpLevelTable[currentPlayerXPLevel];
	int xpTowardsNextLevel = CheckActorInventory(playerTid, "XP") - xpLevelTable[currentPlayerXPLevel];
	int fProgress = FixedDiv(xpTowardsNextLevel, totalXPUntilNextLevel);
	int progressCentigrade = FixedMul(fProgress, 100); //This actually ends up as an integer somehow...
	int oldProgressCentigrade = CheckActorInventory(playerTid, "XPProgress");
	//Log(d:progressCentigrade, s:" ", d:oldProgressCentigrade);
	GiveActorInventory(playerTid, "XPProgress", progressCentigrade-oldProgressCentigrade);

}

//Give the activator XP - can be either the player or another actor!
script 817 (int xp, int source)
{
	int hudwidth = 0;
	int hudheight = 0;

	//If the global XP lock is on, don't give any XP. This is used to prevent players from getting free XP 
	//when all the monsters die after night is over (at daybreak).
	if (g_blockXP) {
		terminate;
	}

    if (xp > 0)
    {
        ActivatorSound("xp", 127);

        for (int i = 8; i >= 0; i--)
        {
            hudwidth = 640 - i*60;
            hudheight = 480 - i*60;
            SetHudSize(hudwidth, hudheight, 1);
            HudMessage(s:"+", d:xp, s:" XP"; HUDMSG_PLAIN, HUDMSG_XP_GAIN, CR_GOLD, ((hudwidth/2)<<16) + 0.4, ((hudheight/3)<<16) + 0.0, 0, 0.8);
            Delay(1);
        }
        
        HudMessage(s:"+", d:xp, s:" XP"; HUDMSG_PLAIN, HUDMSG_XP_GAIN, CR_GOLD, ((hudwidth/2)<<16) + 0.4, ((hudheight/3)<<16), 0.5, 0.8);
        //TODO: Should zoom out, and do it even faster here?

        SetHudSize(0, 0, true);
        
        GiveInventory("XP", xp);
    }
	
		
	//There's a bit of a funny bug in Zandronum's netcode. Internally, the inventory count is stored
	//as a 32-bit integer, but when it's sent over the wire, it's turned into a 16-bit integer,
	//so the client gets signed overflow, but the server still has the correct inventory count.
	//To avoid using the XP count on the client side (which needs the range of a 32-bit integer), 
	//we store the level-up progress bar value as its own inventory item (0-100).
    int playerIdx = ActivatorTID()-PLAYER_MIN_TID;
    recalculateCentigradeWorkaround(playerIdx);

	int currentPlayerXPLevel = CheckInventory("XPLevel");
    /*
	int totalXPUntilNextLevel = xpLevelTable[currentPlayerXPLevel+1] - xpLevelTable[currentPlayerXPLevel];
	int xpTowardsNextLevel = CheckInventory("XP") - xpLevelTable[currentPlayerXPLevel];
	int fProgress = FixedDiv(xpTowardsNextLevel, totalXPUntilNextLevel);
	int progressCentigrade = FixedMul(fProgress, 100); //This actually ends up as an integer somehow...
	int oldProgressCentigrade = CheckInventory("XPProgress");
	//Log(d:progressCentigrade, s:" ", d:oldProgressCentigrade);
	GiveInventory("XPProgress", progressCentigrade-oldProgressCentigrade);
    */

	
	//Check if we need to level up the player
	if (currentPlayerXPLevel >= NUM_XP_LEVELS) { //Don't level up past the max level!
		terminate;
	}
	if (CheckInventory("XP") >= xpLevelTable[currentPlayerXPLevel+1])
	{
		GiveInventory("XPLevel", 1);
		TakeInventory("XPProgress", 100);
		//currentPlayerXPLevel++;
		Delay(18);
		
		hudwidth = 320;
		hudheight = 240;
		SetHudSize(hudwidth, hudheight, 1);
		HudMessage(s:"Level ", d:currentPlayerXPLevel+2; HUDMSG_TYPEON | HUDMSG_LOG, HUDMSG_LEVEL_UP, CR_GREEN, ((hudwidth/2)<<16) + 0.4, ((hudheight/3)<<16), 5.0, 0.1, 2.0);
		//ActivatorSound("HEY", 127);
		musicPlayLevelUp(currentPlayerXPLevel+2);
		
		//Bling bling
		ACS_ExecuteAlways(818, 0, 0);
		
		if ((GameType() != GAME_SINGLE_PLAYER) && (PlayerNumber() != 0)) {
			PrintBold(n:PlayerNumber()+1, s:" has reached level ", d:currentPlayerXPLevel+2, s:"!");
		}
		
		SetHudSize(0, 0, true);	
		
		//Give the player a scroll telling them what they unlocked.
		str scrollItem = StrParam(s:"ScrollLevel", d:currentPlayerXPLevel+2);
		GiveInventory(scrollItem, 1);
	}
}

str confettiActors[6] = {
	"LevelConfetti1",
	"LevelConfetti2",
	"LevelConfetti3",
	"LevelConfetti4",
	"LevelConfetti5",
	"LevelConfetti6",
};
//function void spawnLevelUpBling (void)
script 818 (void)
{
	for (int i = 0; i < 6; i++)
	{
		int r = 32.0;
		str actor = confettiActors[i];
		int delayTics = 1;
		for (int j = 0; j < 3; j++)
		{
			int x = GetActorX(0);
			int y = GetActorY(0);
			int z = GetActorZ(0) + 64.0;
			r += 4.0;
			Spawn(actor, x+FixedMul(r, sin(0.16)), y+FixedMul(r, cos(0.16)), z); Delay(delayTics);
			Spawn(actor, x+FixedMul(r, sin(0.32)), y+FixedMul(r, cos(0.32)), z); Delay(delayTics);
			Spawn(actor, x+FixedMul(r, sin(0.48)), y+FixedMul(r, cos(0.48)), z); Delay(delayTics);
			Spawn(actor, x+FixedMul(r, sin(0.64)), y+FixedMul(r, cos(0.64)), z); Delay(delayTics);
			Spawn(actor, x+FixedMul(r, sin(0.72)), y+FixedMul(r, cos(0.72)), z); Delay(delayTics);
			Spawn(actor, x+FixedMul(r, sin(0.96)), y+FixedMul(r, cos(0.96)), z); Delay(delayTics);
		}
		SpawnProjectile(ActivatorTID(), actor, 0, 40, 0, 1, 0);
		SpawnProjectile(ActivatorTID(), actor, 42, 40, 0, 1, 0);
		SpawnProjectile(ActivatorTID(), actor, 84, 40, 0, 1, 0);
		SpawnProjectile(ActivatorTID(), actor, 126, 40, 0, 1, 0);
		SpawnProjectile(ActivatorTID(), actor, 168, 40, 0, 1, 0);
		SpawnProjectile(ActivatorTID(), actor, 212, 40, 0, 1, 0);
	}
}

/* saveXP */
/** DEPRECATED - DO NOT USE */
script 819 (void)
{
	int playerTid = PLAYER_MIN_TID + PlayerNumber();

	if (!PlayerIsLoggedIn(PlayerNumber()))
	{
		print(s:"You must be logged in save your XP");
		ActivatorSound("menu/invalid", 127);
		SetResultValue(false);
		terminate;
	}
    
    if (!validateSaveAction(PlayerNumber()))
    {
    	Log(s:"There was a problem saving your inventory.");
		ActivatorSound("menu/invalid", 127);
		SetResultValue(false);
		terminate;
    }
    
	str accountName = GetPlayerAccountName(PlayerNumber());
	str namespace = strparam(s:accountName, s:"_inventory");
	
	print(s:"Saving your XP...");
	BeginDBTransaction();

	//XP and level are handled as a special case:
	SetDBEntry(namespace, "XP", CheckActorInventory(playerTid, "XP"));
	SetDBEntry(namespace, "XPLevel", CheckActorInventory(playerTid, "XPLevel"));

	EndDBTransaction();
	print(s:"XP saved!");
	ActivatorSound("switches/normbutn", 127);
	setResultValue(true);
}

//Script 820 - 849 are reserved for MISSIONS.ACS

//Script 850 - 870 are reserved for PLAYER.ACS:
 
//Screen flash when you eat food
script 850 (void)
{
	FadeTo(63, 131, 47, 0.4, 0.2);
	Delay(5);
	FadeTo(0, 0, 0, 0.0, 0.1);
}

//Hunger loop
script 851 (int playerTid)
{
	int hungerIntervalTics = (35 * HUNGER_PERIOD_SECONDS) / MAX_HUNGER_LEVEL; 
    
	while (true)
	{
		Delay(hungerIntervalTics);
    
		int hungerLevel = CheckInventory("HungerLevel");

		//Only apply hunger to XP levels > 14		
		if (CheckInventory("XPLevel") > HUNGER_START_LEVEL-1) {
			GiveActorInventory(playerTid, "HungerLevel", 1);
			if (hungerLevel >= MAX_HUNGER_LEVEL) {
				GiveActorInventory(playerTid, "DeathCurse", 1);
				Thing_Damage2(playerTid, 1000, "Hunger");
				TakeActorInventory(playerTid, "HungerLevel", MAX_HUNGER_LEVEL);
			} 
			else if (hungerLevel >= HUNGER_STARVING_LEVEL)
			{
				Print(s:"You are starving and will die in ", d:((hungerIntervalTics/35)*(MAX_HUNGER_LEVEL-hungerLevel)), s:" seconds\nif you don't eat.");
			}
		}
	}
}


script 852 OPEN
{
    while (true)
    {
        for (int playerIdx = 0; playerIdx < MAX_PLAYERS; playerIdx++) {
            if (!PlayerInGame(playerIdx)) {
                continue;
            }
            if (!PlayerIsLoggedIn(playerIdx)) {
                continue;
            } else {
                //Player is logged in, so check if they've loaded inventory yet...
                if (playerHasLoadedInventory[playerIdx] == 0) {
                    //ACS_ExecuteAlways(814, 0, playerIdx);
                    restorePersistentInventory(playerIdx);
                    Delay(1);
                    warpToTravelPathway(playerIdx);
                    str playerName = getPlayerAccountName(playerIdx);
                    StrCpy(a:g_accountNameForPlayer[playerIdx], playerName);
                    Log(s:"Cached player account as ", a:g_accountNameForPlayer[playerIdx], s:" for player ", s:playerName, s:", index was: ", d:playerIdx);
                }
            }
            
            int playerTid = PLAYER_MIN_TID+playerIdx;

            //Update persistent inventory list for player
            for (int invItemIdx = 0; invItemIdx < PERSISTENT_INVENTORY_LEN; invItemIdx++)
            {
                g_inventoryCountForPlayer[playerIdx][invItemIdx] = CheckActorInventory(playerTid, persistentInventory[invItemIdx]);
            }
            //Print(s:"Updated player inventory list");
        }
        Delay(1);
    }
}

//dropAllPlayerInventoryAsBackpack
script 853 (void)
{
    //Put all the player's inventory in a backpack.
    
    int playerTid = ActivatorTID();
    
    //Spawn a special backpack and give it a TID
    int backpackTid = UniqueTID(SAFE_UNIQUE_TID_MIN, SAFE_UNIQUE_TID_MAX-SAFE_UNIQUE_TID_MIN);
    SpawnForced("DoomZBackpack", GetActorX(playerTid) + 24.0, GetActorY(playerTid), GetActorZ(playerTid), backpackTid, 0);
    
    //SetActorVelocity(backpackTid, GetActorVelX(playerTid), GetActorVelY(playerTid), GetActorVelZ(playerTid), true, false);
    
    //Save the backpack's TID inside a user variable inside the backpack, for convenience.
    SetUserVariable(backpackTid, "user_tid", backpackTid);
        
    //Iterate over all the persistent inventory and give it to the backpack.
    //Save the quantity of each inventory item as a user variable.
    for (int i = DROPPABLE_INVENTORY_START; i < PERSISTENT_INVENTORY_LEN; i++)
    {
        SetUserArray(backpackTid, "user_inventory", i, CheckActorInventory(playerTid, persistentInventory[i]));
        //Log(s:"Saving ", d:CheckActorInventory(playerTid, persistentInventory[i]), s:" ", s:persistentInventory[i], s:" to backpack.");
    }
    
    ClearActorInventory(ActivatorTID());
}

//Unpack a player's dropped backpack.
//Called when a player picks up a backpack.
script 854 (int backpackTid, int blarg)
{
    int playerTid = ActivatorTID();
 
    //Log(s:"backpackTid: ", d:backpackTid, s:", ", s:"blarg: ", d:blarg);
    //Log(s:"Number of actors with backpack tid: ", d:ThingCount(T_NONE, backpackTid));
        
    for (int i = DROPPABLE_INVENTORY_START; i < PERSISTENT_INVENTORY_LEN; i++)
    {
        //Log(s:"Giving player ", s:persistentInventory[i], s:" from backpack.");
        GiveActorInventory(playerTid, persistentInventory[i], GetUserArray(backpackTid, "user_inventory", i));
    }
    
    //Log(s:"Giving player with TID ", d:playerTid, s:" amount ", d:GetUserArray(backpackTid, "user_inventory", 0), s:" from backpack with TID: ", d:backpackTid);

    SetResultValue(true);
}

script 855 (void) NET CLIENTSIDE
{
    /* Long story here: Zandronum has no automatic login feature that's accessible via the built-in Multiplayer->Login menu,
     * but we can hack one together because Zandronum has auto-login via the console.
     * The console-based auto-login uses these two built-in console commands:
     * - login_add [username] [password]
     * - login_default_user [username]
     *
     * Our custom login menu saves username and password to the config file (which the built-in login menu doesn't).
     * This script concatenates that username and password and passes them to login_add, and then sets that as the default,
     * and then invokes a login! These three steps accomplish auto-login, and makes it persist properly across game restarts.
     *
     */
    //Add the username/password as a saved login
    int login_add_cmd = strparam(s:"login_add ", s:GetUserCVarString(PlayerNumber(), "surv_username"), s:" ", s:GetUserCVarString(PlayerNumber(), "surv_password"));
    ConsoleCommand(login_add_cmd);

    //Choose those credentials as the ones to login as by default when the "login" command is invoked with no parameters.
    int login_default_user_cmd = strparam(s:"login_default_user ", s:GetUserCVarString(PlayerNumber(), "surv_username"));
    ConsoleCommand(login_default_user_cmd);

    //Invoke a login.
    ACS_ExecuteAlways(856, 0);
}

//Automatically try to login when a player connects.
script 856 OPEN CLIENTSIDE
{
    //We're syncing our custom cvar's values over to the "menu_*" ones, just for consistency and just in case it's needed...
    int set_authuser_cmd = strparam(s:"menu_authusername ", s:GetUserCVarString(PlayerNumber(), "surv_username"));
    ConsoleCommand(set_authuser_cmd);
    int set_authpass_cmd = strparam(s:"menu_authpassword ", s:GetUserCVarString(PlayerNumber(), "surv_password"));
    ConsoleCommand(set_authpass_cmd);

    ConsoleCommand("login");
}

//Travel a player from one map/server to another!
script 857 (int travelSrcMapIdx, int travelDestMapIdx, int pathwayIdx)
{
    //TODO: Give the player an inventory item that tells the next map
    //      where they should spawn.
    int playerIdx = PlayerNumber();
    int playerTID = PLAYER_MIN_TID + playerIdx;
    if (playerIdx >= 0) {

        if (!PlayerIsLoggedIn(playerIdx))
        {
            Print(s:"You must be logged into travel to this way.");
            ActivatorSound("menu/invalid", 127);
            terminate;
        }

        //Save their inventory and connect them to the next server.
        //TakeActorInventory(playerTID, "TravelDestMap", 0x7FFFFFFF);
        GiveActorInventory(playerTID, "TravelDestMap", travelDestMapIdx);
        //TakeActorInventory(playerTID, "TravelDestPathway", 0x7FFFFFFF);
        Log(s:"Giving player TravelDestPathway: ", d:pathwayIdx);
        GiveActorInventory(playerTID, "TravelDestPathway", pathwayIdx);
        Delay(3);

        SetFont("BIGFONT");
        HudMessage(s:"Travelling..."; HUDMSG_PLAIN, FLASH_MESSAGE_ID, CR_GREEN, 0.5, 0.7, 3.0);
        FadeTo(0, 0, 0, 1.0, 0.5); //Fade to black

        if (ACS_ExecuteAlways(810, 0, playerIdx, true)) {
            //Make the player connect to the other server.
            Delay(18);
            ACS_ExecuteAlways(1001, 0, travelDestMapIdx); //Called on the client side!
        }
    }
}

function void warpToTravelPathway(int playerIdx)
{
    int playerTid = PLAYER_MIN_TID + playerIdx;

    int pathwayIdx = CheckActorInventory(playerTid, "TravelDestPathway");
    if (pathwayIdx <= 0) {
        Log(s:"Player has no TravelDestPathway, not warping.");
        return;
    }
    TakeActorInventory(playerTID, "TravelDestMap", 0x7FFFFFFF);
    TakeActorInventory(playerTID, "TravelDestPathway", 0x7FFFFFFF);

    int pathwayTid = TRAVELPATHWAY_MIN_TID + pathwayIdx;
    Log(s:"Travel pathway TID: ", d:pathwayTid);

    SetActorPosition(playerTid, GetActorX(pathwayTid), GetActorY(pathwayTid), GetActorZ(pathwayTid), false);
    SetActorAngle(playerTid, GetActorAngle(pathwayTid));

}



//script 900-920 reserved for ARTIFACTS.acs
